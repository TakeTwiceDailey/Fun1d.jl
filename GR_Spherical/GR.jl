module GR_Spherical

using DifferentialEquations
using Fun1d
using DataFrames
using CSV
using Plots
using Roots

# using Random

struct GBSSN_Variables{S,T} <: AbstractArray{T,2}
    Œ±::GridFun{S,T}
    A::GridFun{S,T}
    Œ≤r::GridFun{S,T}
    Br::GridFun{S,T}
    œá::GridFun{S,T}
    Œ≥trr::GridFun{S,T}
    Œ≥tŒ∏Œ∏::GridFun{S,T}
    Arr::GridFun{S,T}
    K::GridFun{S,T}
    Œìr::GridFun{S,T}
    ùúô::GridFun{S,T}
    Kùúô::GridFun{S,T}
end

cont(x::GBSSN_Variables) = (x.Œ±, x.A, x.Œ≤r, x.Br, x.œá, x.Œ≥trr, x.Œ≥tŒ∏Œ∏, x.Arr, x.K, x.Œìr, x.ùúô, x.Kùúô)
numvar = 12

# Iteration
Base.IteratorSize(::Type{<:GBSSN_Variables}) = Iterators.HasShape{2}()
Base.eltype(::Type{GBSSN_Variables{S,T}}) where {S,T} = T
Base.isempty(x::GBSSN_Variables) = isempty(x.Œ±)
function Base.iterate(x::GBSSN_Variables, state...)
    return iterate(Iterators.flatten(cont(x)), state...)
end
Base.size(x::GBSSN_Variables) = (length(x.Œ±), numvar)
Base.size(x::GBSSN_Variables, d) = size(x)[d]

# Indexing
function lin2cart(x::GBSSN_Variables, i::Number)
    n = length(x.Œ±)
    return (i - 1) % n + 1, (i - 1) √∑ n + 1
end
Base.firstindex(x::GBSSN_Variables) = error("not implemented")
Base.getindex(x::GBSSN_Variables, i) = getindex(x, i.I...)
Base.getindex(x::GBSSN_Variables, i::Number) = getindex(x, lin2cart(x, i)...)
Base.getindex(x::GBSSN_Variables, i, j) = getindex(cont(x)[j], i)
Base.lastindex(x::GBSSN_Variables) = error("not implemented")
Base.setindex!(x::GBSSN_Variables, v, i) = setindex!(x, v, i.I...)
Base.setindex!(x::GBSSN_Variables, v, i::Number) = setindex!(x, v, lin2cart(x, i))
Base.setindex!(x::GBSSN_Variables, v, i, j) = setindex!(cont(x)[j], v, i)

# Abstract Array
Base.IndexStyle(::GBSSN_Variables) = IndexCartesian()
Base.similar(x::GBSSN_Variables) = GBSSN_Variables(map(similar, cont(x))...)
function Base.similar(x::GBSSN_Variables, ::Type{T}) where {T}
    return GBSSN_Variables(map(y -> similar(y,T), cont(x))...)
end
Base.similar(x::GBSSN_Variables, ::Dims) = similar(x)
Base.similar(x::GBSSN_Variables, ::Dims, ::Type{T}) where {T} = similar(x, T)

# Broadcasting
Base.BroadcastStyle(::Type{<:GBSSN_Variables}) = Broadcast.ArrayStyle{GBSSN_Variables}()
function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{GBSSN_Variables}},
                      ::Type{T}) where {T}
    x = find_GBSSN_Variables(bc)
    return similar(x, T)
end
find_GBSSN_Variables(bc::Base.Broadcast.Broadcasted) = find_GBSSN_Variables(bc.args)
find_GBSSN_Variables(args::Tuple) = find_GBSSN_Variables(find_GBSSN_Variables(args[1]), Base.tail(args))
find_GBSSN_Variables(x) = x
find_GBSSN_Variables(::Tuple{}) = nothing
find_GBSSN_Variables(a::GBSSN_Variables, rest) = a
find_GBSSN_Variables(::Any, rest) = find_GBSSN_Variables(rest)

# Others
function Base.map(fun, x::GBSSN_Variables, ys::GBSSN_Variables...)
    return GBSSN_Variables(
        map(fun, x.Œ±, (y.Œ± for y in ys)...),
        map(fun, x.A, (y.A for y in ys)...),
        map(fun, x.Œ≤r, (y.Œ≤r for y in ys)...),
        map(fun, x.Br, (y.Br for y in ys)...),
        map(fun, x.œá, (y.œá for y in ys)...),
        map(fun, x.Œ≥trr, (y.Œ≥trr for y in ys)...),
        map(fun, x.Œ≥tŒ∏Œ∏, (y.Œ≥tŒ∏Œ∏ for y in ys)...),
        map(fun, x.Arr, (y.Arr for y in ys)...),
        map(fun, x.K, (y.K for y in ys)...),
        map(fun, x.Œìr, (y.Œìr for y in ys)...),
        map(fun, x.ùúô, (y.ùúô for y in ys)...),
        map(fun, x.Kùúô, (y.Kùúô for y in ys)...)
        )
end

# function Base.rand(rng::AbstractRNG, ::Random.SamplerType{GBSSN_Variables{T}}) where {T}
#     return GBSSN_Variables{T}(rand(rng, T), rand(rng, T))
# end

Base.zero(::Type{<:GBSSN_Variables}) = error("not implemented")
Base.zero(x::GBSSN_Variables) = GBSSN_Variables(map(zero, cont(x))...)

Base.:+(x::GBSSN_Variables) = map(+, x)
Base.:-(x::GBSSN_Variables) = map(-, x)

Base.:+(x::GBSSN_Variables, y::GBSSN_Variables) = map(+, x, y)
Base.:-(x::GBSSN_Variables, y::GBSSN_Variables) = map(-, x, y)

Base.:*(x::GBSSN_Variables, a::Number) = map(b -> b * a, x)
Base.:*(a::Number, x::GBSSN_Variables) = map(b -> a * b, x)
Base.:/(x::GBSSN_Variables, a::Number) = map(b -> b / a, x)
Base.:\(a::Number, x::GBSSN_Variables) = map(b -> a \ b, x)

################################################################################

function printlogo()
    # Just a fancy ASCII logo for the program
    println(
"\n",
"           /\\\\\\\\\\\\\\\\\\       /\\\\\\\\\\\\\\\\\\\\\\\\\n",
" ________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/ /\\\\\\\\/ / /\\\\\\\\_____________________________\n",
"  ______//\\\\\\\\\\/ / / / /___\\/ /\\\\\\\\/_/ / /\\\\\\\\___________________________\n",
"   _____//\\\\\\\\/_/_/_/_/_____\\/ /\\\\\\\\ \\/ / /\\\\\\\\___________________________\n",
"    ____/ /\\\\\\\\____/\\\\\\\\\\\\___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\\\\\_______in___________________\n",
"     ___\\/ /\\\\\\\\__/ /  /\\\\\\___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\/________Spherical____________\n",
"      ___\\/ /\\\\\\\\_\\/__/ /\\\\\\___\\/ /\\\\\\\\ / /\\\\\\\\__________Symmetry____________\n",
"       ___\\/ /\\\\\\\\____\\/ /\\\\\\___\\/ /\\\\\\\\_/ //\\\\\\\\_____________________________\n",
"        ___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\/ /\\\\\\\\\\// //\\\\\\\\____________________________\n",
"         ___\\/ / /\\\\\\\\\\\\\\\\\\  /____\\/ /\\\\\\\\_\\// //\\\\\\\\_____by Erik Schnetter_____\n",
"          ___\\/_/ / / / / /_/______\\/ /  /___\\// /  /_______and Conner Dailey____\n",
"           _____\\/_/_/_/_/__________\\/__/______\\/__/______________________________\n"
)

end

function setup(::Type{S}, rspan, points::Int) where {S}

    # Specify the radial domain and the
    # radial step amount and make a Grid object
    rmin,rmax = rspan
    domain = Domain{S}(rmin, rmax)
    grid = Grid(domain, points)
    return grid

end

function dissipation(f::GridFun{S,T}) where {S,T}

    ############################################
    # Calculates the numerical dissipation terms
    #
    # Finite differencing fails to model high
    # frequency modes in the system, and these
    # modes can lead to instabilities. Adding
    # numerical dissipation terms damps these
    # high frequency modes by subtracting off
    # a high order derivative from each dynamical
    # variable in the system.
    ############################################

    dx = spacing(f.grid)
    n = f.grid.ncells + 4
    dvalues = Array{T}(undef, n)

    # if f.values[2] == 0.
    #     dvalues[3:6] .= ((f.values[3] - 6*f.values[4] + 15*f.values[5]
    #     - 20*f.values[6] + 15*f.values[7] - 6*f.values[8] + f.values[9])/(dx^6))
    # else
    #     dvalues[3:6] .= ((f.values[2] - 6*f.values[3] + 15*f.values[4]
    #     - 20*f.values[5] + 15*f.values[6] - 6*f.values[7] + f.values[8])/(dx^6))
    # end
    #
    # for i in 7:(n - 5)
    #     dvalues[i] =  ((f.values[i-3] - 6*f.values[i-2] + 15*f.values[i-1]
    #     - 20*f.values[i] + 15*f.values[i+1] - 6*f.values[i+2] + f[i+3])/(dx^6))
    # end
    #
    # dvalues[(n-4):(n-2)] .= ((f.values[n-8] - 6*f.values[n-7] + 15*f.values[n-6]
    # - 20*f.values[n-5] + 15*f.values[n-4] - 6*f.values[n-3] + f.values[n-2])/(dx^6))

    # if f.values[2] == 0.
    #     for i in 3:4
    #         dvalues[i] = ((f.values[i] - 4*f.values[i+1] + 6*f.values[i+2]
    #         - 4*f.values[i+3] + f.values[i+4])/(dx^4))
    #     end
    # else
    #     dvalues[3:4] .= ((f.values[2] - 4*f.values[3] + 6*f.values[4]
    #     - 4*f.values[5] + f.values[6])/(dx^4))
    # end

    # dvalues[1:4] .= 0.
    # # dvalues[3] = ((6*f.values[1] + 15*f.values[2]
    # # - 20*f.values[3] + 15*f.values[4] - 6*f.values[5]
    # # + f.values[6])/(dx^6))
    #
    # for i in 3:3
    #     dvalues[i] = ((f.values[i-2] - 4*f.values[i-1] + 6*f.values[i]
    #     - 4*f.values[i+1] + f.values[i+2])/(dx^4))
    # end
    # for i in 4:(n - 5)
    #     dvalues[i] = ((-f.values[i-3] + 12*f.values[i-2] -39*f.values[i-1]
    #     + 56*f.values[i] - 39*f.values[i+1] + 12*f.values[i+2]
    #     - f.values[i+3])/(dx^4))
    # end
    # dvalues[(n-4):n] .= 0.

    dvalues[1:2] .= 0.
    for i in 3:(n - 4)
        dvalues[i] = ((f.values[i-2] - 4*f.values[i-1] + 6*f.values[i]
        - 4*f.values[i+1] + f.values[i+2])/(dx^4))
    end
    dvalues[(n-3):n] .= 0.

    return GridFun(f.grid, dvalues)
end


function init(::Type{T}, grid::Grid, param) where {T}

    ############################################
    # Specifies the Initial Conditions
    ############################################

    n = grid.ncells + 4
    domain = grid.domain
    initgrid = grid
    drt = spacing(grid)
    r = param[4]
    drdrt = param[5]
    d2rdrt = param[6]
    m = param[7]

    num = 0

    # Initial conditions for Schwarzschild metric (Ker-Schild Coordinates)

    # Mass (no real reason not to use 1 here)
    M = 1

    fŒ±(rt) = real((1+2*M/(r(rt))+0im)^(-1/2))
    fA(rt) = 0.
    fŒ≤r(rt) = (2*M/r(rt))/(1+2*M/r(rt))
    fBr(rt) = 0.
    fœá(rt) = 1.
    fŒ≥trr(rt) = 1+2*M/r(rt)
    fŒ≥tŒ∏Œ∏(rt) = r(rt)^2
    fArr(rt) = -(4*M/3)*(3*M+2*r(rt))/real(((r(rt)^5)*(r(rt)+2*M)+0im)^(1/2))
    fK(rt) = (2*M)*(3*M+r(rt))/real((r(rt)*(r(rt)+2*M)+0im)^(3/2))
    fŒìr(rt) = -(2*r(rt)+5*M)/(r(rt)+2*M)^2

    r0 = 10
    œÉr = 0.5
    Amp = 0.1

    fùúô(rt) = Amp*(1/r(rt))*exp(-(1/2)*((r(rt)-r0)/œÉr)^2)
    f‚àÇùúô(rt) = Amp*exp(-(1/2)*((r(rt)-r0)/œÉr)^2)*(r(rt)*r0-r(rt)^2-œÉr^2)/(r(rt)^2*œÉr^2)
    f‚àÇtùúô(rt) = 0.

    f‚àÇœá(rt) = 0.
    f‚àÇŒ≥trr(rt) = -2*M/(r(rt)^2)
    f‚àÇŒ≥tŒ∏Œ∏(rt) = 2*r(rt)
    f‚àÇArr(rt) = (4*M/3)*(15*M^2+15*M*r(rt)+4*r(rt)^2)/real(((r(rt)^7)*((r(rt)+2*M)^3)+0im)^(1/2))
    f‚àÇK(rt) = -2*M*(9*M^2+10*M*r(rt)+2*r(rt)^2)/real((r(rt)*(r(rt)+2*M)+0im)^(5/2))
    f‚àÇŒìr(rt) = 2*(r(rt)+3*M)/(r(rt)+2*M)^3

    f‚àÇ2Œ≥tŒ∏Œ∏(rt) = 2

    fgtt(rt) = -(1/fŒ±(rt)^2)
    fgtr(rt) = fŒ≤r(rt)/fŒ±(rt)^2
    fgrr(rt,œá) = œá/fŒ≥trr(rt) - (fŒ≤r(rt)/fŒ±(rt))^2

    # Lagrangian Density for scalar field

    fùìõ(rt,œá) = ((1/2)*fgtt(rt)*f‚àÇtùúô(rt)^2 + (1/2)*fgrr(rt,œá)*f‚àÇùúô(rt)^2 + fgtr(rt)*f‚àÇùúô(rt)*f‚àÇtùúô(rt) - (1/2)*(m^2)*fùúô(rt)^2)

    # Stresss Energy components (contravariant indices)

    fTtt(rt,œá) = (fgtt(rt)*f‚àÇtùúô(rt) + fgtr(rt)*f‚àÇùúô(rt)).^2 - fgtt(rt)*fùìõ(rt,œá)
    fTtr(rt,œá) = ((fgtt(rt)*f‚àÇtùúô(rt) + fgtr(rt)*f‚àÇùúô(rt))*(fgtr(rt)*f‚àÇtùúô(rt) + fgrr(rt,œá)*f‚àÇùúô(rt)) - fgtr(rt)*fùìõ(rt,œá))

    fœÅ(rt,œá) = (fŒ±(rt)^2)*fTtt(rt,œá)
    fSr(rt,œá) = fŒ±(rt)*fTtr(rt,œá)

    f‚àÇœá(rt,(œá, X, Arr)) = X

    function f‚àÇX(rt,(œá, X, Arr))
     -(1/2)*fŒ≥trr(rt)*(-(3/2)*(Arr/fŒ≥trr(rt))^2 + (2/3)*fK(rt)^2
     - (5/2)*((X^2)/œá)/fŒ≥trr(rt)
     + 2*œá/fŒ≥tŒ∏Œ∏(rt) - 2*œá*(f‚àÇ2Œ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt)
     + 2*X*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt)
     + œá*(f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2))*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))
     - X*f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2)
     + (1/2)*œá*((f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))^2)/fŒ≥trr(rt) - 16*pi*fœÅ(rt,œá))
    end

    function f‚àÇArr(rt,(œá, X, Arr))
     -fŒ≥trr(rt)*(-(2/3)*f‚àÇK(rt) - (3/2)*Arr*(X/œá)/fŒ≥trr(rt)
     + (3/2)*Arr*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt) - Arr*f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2)
     - 8*pi*fŒ≥trr(rt)*fSr(rt,œá)/œá)
    end

    # grid = Grid(domain,Int((2^num)*(n-5)+1))
    # n = grid.ncells + 4

    Œ± = sample(T, grid, fŒ±)
    A = sample(T, grid, fA)
    Œ≤r = sample(T, grid, fŒ≤r)
    Br = sample(T, grid, fBr)
    œá = sample(T, grid, fœá)
    Œ≥trr = sample(T, grid, fŒ≥trr)
    Œ≥tŒ∏Œ∏ = sample(T, grid, fŒ≥tŒ∏Œ∏)
    Arr = sample(T, grid, fArr)
    K = sample(T, grid, fK)
    Œìr = sample(T, grid, fŒìr)
    ùúô = sample(T, grid, fùúô)
    ‚àÇùúô = sample(T, grid, f‚àÇùúô)
    ‚àÇtùúô = sample(T, grid, f‚àÇtùúô)

    ‚àÇœá = sample(T, grid, f‚àÇœá)
    # ‚àÇŒ≥trr = sample(T, grid, f‚àÇŒ≥trr)
    # ‚àÇŒ≥tŒ∏Œ∏ = sample(T, grid, f‚àÇŒ≥tŒ∏Œ∏)
    # ‚àÇK = sample(T, grid, f‚àÇK)
    ‚àÇArr = sample(T, grid, f‚àÇArr)

    # ‚àÇ2Œ≥tŒ∏Œ∏ = sample(T, grid, f‚àÇ2Œ≥tŒ∏Œ∏)
    #
    # order = 4
    #
    rr = sample(T, grid, param[4])
    # drdrt = sample(Float64, grid, param[5])
    #
    # ‚àÇrtùúô = deriv(ùúô,order,1)
    # ‚àÇùúô = ‚àÇrtùúô./drdrt

    Kùúô = -(‚àÇtùúô - Œ≤r.*‚àÇùúô)./(2*Œ±)

    X = ‚àÇœá
    ‚àÇX = sample(T, grid, rt -> 0.)

    Kreg = real((rr .+ 0im).^(3/2)).*K
    # ‚àÇKreg = real((r .+ 0im).^(3/2)).*‚àÇK + (3/2)*real((r .+ 0im).^(1/2)).*K
    # Arrreg = real((r .+ 0im).^(5/2)).*Arr
    # ‚àÇArrreg = real((r .+ 0im).^(5/2)).*‚àÇArr + (5/2)*real((r .+ 0im).^(3/2)).*Arr
    #
    Œ≥tŒ∏Œ∏reg = sample(T, grid, rt -> 0)

    # # Inverse metric (contravariant indices)
    #
    # gtt = -(1 ./Œ±.^2)
    # gtr = Œ≤r./Œ±.^2
    # grr = œá./Œ≥trr - (Œ≤r./Œ±).^2
    # gŒ∏Œ∏ = œá./Œ≥tŒ∏Œ∏
    #
    # # Lagrangian Density for scalar field
    #
    # ùìõ = (1/2)*gtt.*‚àÇtùúô.^2 + (1/2)*grr.*‚àÇùúô.^2 + gtr.*‚àÇùúô.*‚àÇtùúô - (1/2)*(m^2)*ùúô.^2
    #
    # # Stresss Energy components (contravariant indices)
    #
    # Ttt = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).^2 - gtt.*ùìõ
    # Ttr = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).*(gtr.*‚àÇtùúô + grr.*‚àÇùúô) - gtr.*ùìõ
    #
    # œÅ = (Œ±.^2).*Ttt
    # Sr = Œ±.*Ttr

    # Constraint Equations

    rt = domain.xmin - drt
    r = param[4]

    for i = 2:n-1

        ‚àÇœá[i] = f‚àÇœá(rt,(œá[i], X[i], Arr[i]))
        ‚àÇX[i] = f‚àÇX(rt,(œá[i], X[i], Arr[i]))
        ‚àÇArr[i] = f‚àÇArr(rt,(œá[i], X[i], Arr[i]))

        œá[i+1] = œá[i] + drt*(3*‚àÇœá[i]-‚àÇœá[i-1])/2
        X[i+1] = X[i] + drt*(3*‚àÇX[i]-‚àÇX[i-1])/2
        Arr[i+1] = Arr[i] + drt*(3*‚àÇArr[i]-‚àÇArr[i-1])/2

        # k2œá = f‚àÇœá(rt+drt/2,(œá[i]+drt*k1œá/2,X[i]+drt*k1X/2,Arr[i]+drt*k1Arr/2))
        # k2X = f‚àÇX(rt+drt/2,(œá[i]+drt*k1œá/2,X[i]+drt*k1X/2,Arr[i]+drt*k1Arr/2))
        # k2Arr = f‚àÇArr(rt+drt/2,(œá[i]+drt*k1œá/2,X[i]+drt*k1X/2,Arr[i]+drt*k1Arr/2))
        #
        # k3œá = f‚àÇœá(rt+drt/2,(œá[i]+drt*k2œá/2,X[i]+drt*k2X/2,Arr[i]+drt*k2Arr/2))
        # k3X = f‚àÇX(rt+drt/2,(œá[i]+drt*k2œá/2,X[i]+drt*k2X/2,Arr[i]+drt*k2Arr/2))
        # k3Arr = f‚àÇArr(rt+drt/2,(œá[i]+drt*k2œá/2,X[i]+drt*k2X/2,Arr[i]+drt*k2Arr/2))
        #
        # k4œá = f‚àÇœá(rt+drt,(œá[i]+drt*k3œá,X[i]+drt*k3X,Arr[i]+drt*k3Arr))
        # k4X = f‚àÇX(rt+drt,(œá[i]+drt*k3œá,X[i]+drt*k3X,Arr[i]+drt*k3Arr))
        # k4Arr = f‚àÇArr(rt+drt,(œá[i]+drt*k3œá,X[i]+drt*k3X,Arr[i]+drt*k3Arr))

        # œá[i+1] = œá[i] + drt*(k1œá + 2*k2œá + 2*k3œá + k4œá)/6
        # X[i+1] = X[i] + drt*(k1X + 2*k2X + 2*k3X + k4X)/6
        # Arr[i+1] = Arr[i] + drt*(k1Arr + 2*k2Arr + 2*k3Arr + k4Arr)/6

        # Arrreg[i] = real((r(rt)+ 0im)^(5/2))*Arr[i]
        # k1Arrreg = real((r(rt)+ 0im)^(5/2))*k1Arr + (5/2)*real((r(rt)+ 0im)^(3/2))*Arr[i]
        # k2Arrreg = real((r(rt+drt/2)+ 0im)^(5/2))*k2Arr + (5/2)*real((r(rt+drt/2)+ 0im)^(3/2))*(Arr[i]+drt*k1Arr/2)
        # k3Arrreg = real((r(rt+drt/2)+ 0im)^(5/2))*k3Arr + (5/2)*real((r(rt+drt/2)+ 0im)^(3/2))*(Arr[i]+drt*k2Arr/2)
        # k4Arrreg = real((r(rt+drt)+ 0im)^(5/2))*k4Arr + (5/2)*real((r(rt+drt)+ 0im)^(3/2))*(Arr[i]+drt*k3Arr)
        #
        # Arrreg[i+1] = Arrreg[i] + drt*(k1Arrreg + 2*k2Arrreg + 2*k3Arrreg + k4Arrreg)/6
        #
        # Arr[i+1] = real((r(rt+drt)+ 0im)^(-5/2))*Arrreg[i+1]
        #
        #Arr[i+1] = Arr[i] + drt*(k1Arr + 2*k2Arr + 2*k3Arr + k4Arr)/6
        #
        # Arrreg[i+1] = real((r(rt+drt)+ 0im)^(5/2))*Arr[i+1]

        # grr[i] = œá[i]/Œ≥trr[i] - (Œ≤r[i]/Œ±[i])^2
        # gŒ∏Œ∏[i] = œá[i]/Œ≥tŒ∏Œ∏[i]
        #
        # ùìõ[i] = ((1/2)*gtt[i]*‚àÇtùúô[i]^2 + (1/2)*grr[i]*‚àÇùúô[i]^2
        # + gtr[i]*‚àÇùúô[i]*‚àÇtùúô[i] - (1/2)*(m^2)*ùúô[i]^2)
        #
        # Ttt[i] = (gtt[i]*‚àÇtùúô[i] + gtr[i]*‚àÇùúô[i])^2 - gtt[i]*ùìõ[i]
        # Ttr[i] = ((gtt[i]*‚àÇtùúô[i] + gtr[i]*‚àÇùúô[i])*(gtr[i]*‚àÇtùúô[i] + grr[i]*‚àÇùúô[i])
        # - gtr[i]*ùìõ[i])
        #
        # œÅ[i] = (Œ±[i]^2)*Ttt[i]
        # Sr[i] = Œ±[i]*Ttr[i]
        #
        # ‚àÇœá[i] = X[i]
        #
        # ‚àÇX[i] = -(1/2)*Œ≥trr[i]*(-(3/2)*(Arr[i]/Œ≥trr[i])^2 + (2/3)*K[i]^2
        #  - (5/2)*((X[i]^2)/œá[i])/Œ≥trr[i]
        #  + 2*œá[i]/Œ≥tŒ∏Œ∏[i] - 2*œá[i]*(‚àÇ2Œ≥tŒ∏Œ∏[i]/Œ≥tŒ∏Œ∏[i])/Œ≥trr[i]
        #  + 2*X[i]*(‚àÇŒ≥tŒ∏Œ∏[i]/Œ≥tŒ∏Œ∏[i])/Œ≥trr[i]
        #  + œá[i]*(‚àÇŒ≥trr[i]/(Œ≥trr[i]^2))*(‚àÇŒ≥tŒ∏Œ∏[i]/Œ≥tŒ∏Œ∏[i])
        #  - X[i]*‚àÇŒ≥trr[i]/(Œ≥trr[i]^2)
        #  + (1/2)*œá[i]*((‚àÇŒ≥tŒ∏Œ∏[i]/Œ≥tŒ∏Œ∏[i])^2)/Œ≥trr[i] - 16*pi*œÅ[i])
        #
        # ‚àÇArr[i] = -Œ≥trr[i]*(-(2/3)*‚àÇK[i] - (3/2)*Arr[i]*(X[i]/œá[i])/Œ≥trr[i]
        #  + (3/2)*Arr[i]*(‚àÇŒ≥tŒ∏Œ∏[i]/Œ≥tŒ∏Œ∏[i])/Œ≥trr[i] - Arr[i]*‚àÇŒ≥trr[i]/(Œ≥trr[i]^2)
        #  - 8*pi*Œ≥trr[i]*Sr[i]/œá[i])
        #
        # œá[i+1] = œá[i] + dr*(3*‚àÇœá[i]-‚àÇœá[i-1])/2
        # X[i+1] = X[i] + dr*(3*‚àÇX[i]-‚àÇX[i-1])/2

        tol = 1.
        atol = eps(T)^(T(3) / 4)

        while true

            initœá = œá[i+1]
            initX = X[i+1]
            initArr = Arr[i+1]

            #Arr[i+1] = real((r(rt+drt)+ 0im)^(-5/2))*Arrreg[i+1]

            ‚àÇœá[i+1] = f‚àÇœá(rt+drt,(œá[i+1],X[i+1],Arr[i+1]))
            ‚àÇX[i+1] = f‚àÇX(rt+drt,(œá[i+1],X[i+1],Arr[i+1]))
            ‚àÇArr[i+1] = f‚àÇArr(rt+drt,(œá[i+1],X[i+1],Arr[i+1]))

            #‚àÇArrreg[i+1] = real((r(rt+drt)+ 0im)^(5/2))*‚àÇArr[i+1] + (5/2)*real((r(rt+drt)+ 0im)^(3/2))*Arr[i+1]

            œá[i+1] = œá[i] + drt*(‚àÇœá[i] + ‚àÇœá[i+1])/2
            X[i+1] = X[i] + drt*(‚àÇX[i] + ‚àÇX[i+1])/2
            Arr[i+1] = Arr[i] + drt*(‚àÇArr[i] + ‚àÇArr[i+1])/2

            global tol = maximum(abs.((initœá-œá[i+1],initX-X[i+1],initArr-Arr[i+1])))

            if tol < atol
                break
            end

        end

        rt += drt

     end

    #  grid = initgrid
    #  n = grid.ncells + 4
    #
    #  r = param[4]
    #  drdrt = param[5]
    #  d2rdrt = param[6]
    #
    #  Œ± = sample(T, grid, fŒ±)
    #  A = sample(T, grid, fA)
    #  Œ≤r = sample(T, grid, fŒ≤r)
    #  Br = sample(T, grid, fBr)
    #  Œ≥trr = sample(T, grid, fŒ≥trr)
    #  Œ≥tŒ∏Œ∏reg = sample(T, grid, rt -> 0)
    #  K = sample(T, grid, fK)
    #  Œìr = sample(T, grid, fŒìr)
    #  ùúô = sample(T, grid, fùúô)
    #  ‚àÇtùúô = sample(T, grid, f‚àÇtùúô)
    #
    #  dsœá = sample(T, grid, fœá)
    #  dsArr = sample(T, grid, fArr)
    #
    #  r = sample(T, grid, param[4])
    #  drdrt = sample(T, grid, param[5])
    #
    #  Kreg = real((r .+ 0im).^(3/2)).*K
    #dsArrreg = real((r.+0im).^(5/2)).*dsArr
    #
    #  ‚àÇrtùúô = deriv(ùúô,order,1)
    #  ‚àÇùúô = ‚àÇrtùúô./drdrt
    #
    #  Kùúô = -(‚àÇtùúô - Œ≤r.*‚àÇùúô)./(2*Œ±)
    #
    #  for i = 3:n-3
    #
    #      val = Int((i-3)*(2^num) + 3)
    #
    #      dsœá[i] = œá[val]
    #      dsArr[i] =  Arr[val]
    #      dsArrreg[i] = real((r[i]+0im)^(5/2))*dsArr[i]
    #
    #      if (i < 10 || i > n - 6 )
    #         println(val)
    #     end
    #
    # end

    #rr = sample(T, grid, param[4])

    Arrreg = real((rr.+0im).^(5/2)).*Arr

    Œ± = sample(T, grid, fŒ±)
    A = sample(T, grid, fA)
    Œ≤r = sample(T, grid, fŒ≤r)
    Br = sample(T, grid, fBr)
    œá = sample(T, grid, fœá)
    Œ≥trr = sample(T, grid, fŒ≥trr)
    Œ≥tŒ∏Œ∏ = sample(T, grid, fŒ≥tŒ∏Œ∏)
    Arr = sample(T, grid, fArr)
    K = sample(T, grid, fK)
    Œìr = sample(T, grid, fŒìr)
    ùúô = sample(T, grid, rt->0)
    Kùúô = sample(T, grid, rt->0)

    Kreg = real((rr .+ 0im).^(3/2)).*K
    Arrreg = real((rr .+ 0im).^(5/2)).*Arr
    Œ≥tŒ∏Œ∏reg = sample(T, grid, rt -> 0)


    state = GBSSN_Variables(Œ±, A, Œ≤r, Br, œá, Œ≥trr, Œ≥tŒ∏Œ∏reg, Arrreg, Kreg, Œìr, ùúô, Kùúô)

    cons = constraints(T,state,param)

    plot(rr[3:n-10],cons[1][3:n-10])

    #return GBSSN_Variables(Œ±, A, Œ≤r, Br, dsœá, Œ≥trr, Œ≥tŒ∏Œ∏reg, dsArrreg, Kreg, Œìr, ùúô, Kùúô)

end


function rhs(state::GBSSN_Variables, param, t)

    ############################################
    # Caculates the right hand ride of the
    # evolved variables
    #
    # This is the main meat of the program.
    # This function contains all of the boundary
    # conditions, coordinate conversions,
    # spatial derivative calculations,
    # evolution equations, and numerical
    # dissipation. Each time the Julia DiffEq
    # Solver moves one time step, it calls
    # this function to calculate the new
    # values of the evolved variables.
    ############################################

    # Unpack the Variables

    Œ± = state.Œ±
    A = state.A
    Œ≤r = state.Œ≤r
    Br = state.Br
    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arrreg = state.Arr
    Kreg = state.K
    Œìr = state.Œìr
    ùúô = state.ùúô
    Kùúô =state.Kùúô

    drt = spacing(Œ±.grid)
    n = Œ±.grid.ncells + 4

    m = param[7]

    # Boundary Conditions

    # These inner boundary conditions are necessary for stable
    # evolution for the specified gauge condition and do not
    # specify anything physical about the system.

    # Eulerian/Lagrangian condition (0/1)
    v = param[3]

    # if v == 0 # Eulerian Condition
    #     Œ≤r[2] = (17*Œ≤r[3] + 9*Œ≤r[4] - 5*Œ≤r[5] + Œ≤r[6])/22
    # elseif v == 1 # Lagrangian Condition
    #     Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4]
    #     - 126*Œ≥tŒ∏Œ∏reg[5] + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    #     #Œ≤r[2] = (-315*Œ≤r[3] + 210*Œ≤r[4] - 126*Œ≤r[5] + 45*Œ≤r[6] - 7*Œ≤r[7])/63
    # end

    # Spatial Derivatives (finite differences) with respect to coordinate rt

    # Accuarcy order, 2 for 2nd order, 4 for 4th order
    order = 4

    # First derivatives
    ‚àÇrtŒ± = deriv(Œ±,order,1)
    ‚àÇrtŒ≤r = deriv(Œ≤r,order,-1)
    ‚àÇrtBr = deriv(Br,order,-1)
    ‚àÇrtœá = deriv(œá,order,1)
    ‚àÇrtŒ≥trr = deriv(Œ≥trr,order,1)
    ‚àÇrtŒ≥tŒ∏Œ∏reg = deriv(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇrtArrreg = deriv(Arrreg,order,1)
    ‚àÇrtKreg = deriv(Kreg,order,1)
    ‚àÇrtŒìr = deriv(Œìr,order,-1)
    ‚àÇrtùúô = deriv(ùúô,order,1)
    ‚àÇrtKùúô = deriv(Kùúô,order,-1)

    # Second derivatives
    ‚àÇ2rtŒ± = deriv2(Œ±,order,1)
    ‚àÇ2rtŒ≤r = deriv2(Œ≤r,order,-1)
    ‚àÇ2rtœá = deriv2(œá,order,1)
    ‚àÇ2rtŒ≥trr = deriv2(Œ≥trr,order,1)
    ‚àÇ2rtŒ≥tŒ∏Œ∏reg = deriv2(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇ2rtùúô = deriv2(ùúô,order,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    r = sample(Float64, Œ±.grid, param[4])
    drdrt = sample(Float64, Œ±.grid, param[5])
    d2rdrt = sample(Float64, Œ±.grid, param[6])

    ‚àÇŒ± = ‚àÇrtŒ±./drdrt
    ‚àÇŒ≤r = ‚àÇrtŒ≤r./drdrt
    ‚àÇBr = ‚àÇrtBr./drdrt
    ‚àÇœá = ‚àÇrtœá./drdrt
    ‚àÇŒ≥trr = ‚àÇrtŒ≥trr./drdrt
    ‚àÇŒ≥tŒ∏Œ∏reg = ‚àÇrtŒ≥tŒ∏Œ∏reg./drdrt
    ‚àÇArrreg = ‚àÇrtArrreg./drdrt
    ‚àÇKreg = ‚àÇrtKreg./drdrt
    ‚àÇŒìr = ‚àÇrtŒìr./drdrt
    ‚àÇùúô = ‚àÇrtùúô./drdrt
    ‚àÇKùúô = ‚àÇrtKùúô./drdrt

    ‚àÇ2Œ± = (‚àÇ2rtŒ± - d2rdrt.*‚àÇŒ±)./(drdrt.^2)
    ‚àÇ2Œ≤r = (‚àÇ2rtŒ≤r - d2rdrt.*‚àÇŒ≤r)./(drdrt.^2)
    ‚àÇ2œá = (‚àÇ2rtœá - d2rdrt.*‚àÇœá)./(drdrt.^2)
    ‚àÇ2Œ≥trr = (‚àÇ2rtŒ≥trr - d2rdrt.*‚àÇŒ≥trr)./(drdrt.^2)
    ‚àÇ2Œ≥tŒ∏Œ∏reg = (‚àÇ2rtŒ≥tŒ∏Œ∏reg - d2rdrt.*‚àÇŒ≥tŒ∏Œ∏reg)./(drdrt.^2)
    ‚àÇ2ùúô = (‚àÇ2rtùúô - d2rdrt.*‚àÇùúô)./(drdrt.^2)

    # r[1:2] .= 0.
    # Œ≤r[1:2] .= 0.
    # Œ≥tŒ∏Œ∏reg[1:2] .= 0.
    # Œìr[1:2] .= 0.

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇŒ≥tŒ∏Œ∏ = (r.^2).*‚àÇŒ≥tŒ∏Œ∏reg + (2*r).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇ2Œ≥tŒ∏Œ∏ = (r.^2).*‚àÇ2Œ≥tŒ∏Œ∏reg + (4*r).*‚àÇŒ≥tŒ∏Œ∏reg + 2*(Œ≥tŒ∏Œ∏reg .+ 1)

    # Œ≥tŒ∏Œ∏[1:2] .= 0.
    # ‚àÇŒ≥tŒ∏Œ∏[1:2] .= 0.
    # ‚àÇ2Œ≥tŒ∏Œ∏[1:2] .= 0.

    K = real((r .+ 0im).^(-3/2)).*Kreg
    ‚àÇK = real((r .+ 0im).^(-3/2)).*‚àÇKreg - (3/2)*real((r .+ 0im).^(-5/2)).*Kreg

    Arr = real((r .+ 0im).^(-5/2)).*Arrreg
    ‚àÇArr = real((r .+ 0im).^(-5/2)).*‚àÇArrreg - (5/2)*real((r .+ 0im).^(-7/2)).*Arrreg

    # Œìr = -(2 ./r).*Œìreg
    # ‚àÇŒìr = -(2 ./r).*‚àÇŒìreg + (2 ./(r.^2)).*Œìreg

    # Œìr = Œìreg
    # ‚àÇŒìr = ‚àÇŒìreg

    # Gauge Conditions

    # Coordinate drift parameter.
    # Positive values lead to continued evolution
    # zero gives eventual steady state
    Œ∑ = 0

    #Superscript condition...1 is a plus, 0 is a minus
    a = 0

    #Subscript condition...1 is a plus, 0 is a minus
    b = 0

    # Zero condition, 1 includes shift, 0 for vanishing shift
    # if this is 0, a and b don't matter as long as the
    # initial shift is zero
    c = 1

    #########################################################
    # Evolution Equations
    #
    # This is the full suite of evolution equations
    # for GR in spherical symmetry in the BSSN framework.
    # I have tried to keep them looking as close to their
    # mathematically written counterpart as possible.
    #
    # They are written in the order they appear in the
    # reference (arXiv:0705.3845v2) except for the ‚àÇtBr
    # equation since it contains a ‚àÇtŒìr term.
    #
    #########################################################

    ‚àÇtŒ± = a*Œ≤r.*‚àÇŒ± - 2*Œ±.*A

    ‚àÇtŒ≤r = c*((3/4)*Br + b*Œ≤r.*‚àÇŒ≤r)

    ‚àÇtœá = ((2/3)*K.*Œ±.*œá - (1/3)*v*Œ≤r.*œá.*‚àÇŒ≥trr./Œ≥trr - (2/3)*v*Œ≤r.*œá.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏
     - (2/3)*v*œá.*‚àÇŒ≤r + Œ≤r.*‚àÇœá)

    ‚àÇtŒ≥trr = (-2*Arr.*Œ± - (1/3)*v*Œ≤r.*‚àÇŒ≥trr + Œ≤r.*‚àÇŒ≥trr
     - (2/3)*v*Œ≥trr.*Œ≤r.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ + 2*Œ≥trr.*‚àÇŒ≤r - (2/3)*v*Œ≥trr.*‚àÇŒ≤r)

    ‚àÇtŒ≥tŒ∏Œ∏ = (Arr.*Œ≥tŒ∏Œ∏.*Œ±./Œ≥trr - (1/3)*v*Œ≥tŒ∏Œ∏.*Œ≤r.*‚àÇŒ≥trr./Œ≥trr - (2/3)*v*Œ≤r.*‚àÇŒ≥tŒ∏Œ∏
     + Œ≤r.*‚àÇŒ≥tŒ∏Œ∏ - (2/3)*v*Œ≥tŒ∏Œ∏.*‚àÇŒ≤r)

    ‚àÇtArr = (-2*Œ±.*(Arr.^2)./Œ≥trr + K.*Œ±.*Arr - (1/3)*v*Œ≤r.*Arr.*‚àÇŒ≥trr./Œ≥trr
     - (2/3)*v*Œ≤r.*Arr.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (2/3)*v*Arr.*‚àÇŒ≤r + 2*Arr.*‚àÇŒ≤r
     + (2/3)*Œ±.*œá.*(‚àÇŒ≥trr./Œ≥trr).^2 - (1/3)*Œ±.*œá.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2
     - (1/6)*Œ±.*(‚àÇœá.^2)./œá - (2/3)*Œ±.*œá.*Œ≥trr./Œ≥tŒ∏Œ∏ + Œ≤r.*‚àÇArr
     + (2/3)*Œ±.*œá.*Œ≥trr.*‚àÇŒìr - (1/2)*Œ±.*œá.*(‚àÇŒ≥trr./Œ≥trr).*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)
     + (1/3)*œá.*‚àÇŒ≥trr.*‚àÇŒ±./Œ≥trr + (1/3)*œá.*‚àÇŒ±.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (1/6)*Œ±.*‚àÇŒ≥trr.*‚àÇœá./Œ≥trr
     - (1/6)*Œ±.*‚àÇŒ≥tŒ∏Œ∏.*‚àÇœá./Œ≥tŒ∏Œ∏ - (2/3)*‚àÇŒ±.*‚àÇœá - (1/3)*Œ±.*œá.*‚àÇ2Œ≥trr./Œ≥trr
     + (1/3)*Œ±.*œá.*‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (2/3)*œá.*‚àÇ2Œ± + (1/3)*Œ±.*‚àÇ2œá)

    ‚àÇtK = ((3/2)*Œ±.*(Arr./Œ≥trr).^2 + (1/3)*Œ±.*K.^2 + Œ≤r.*‚àÇK
     + (1/2)*œá.*‚àÇŒ≥trr.*‚àÇŒ±./(Œ≥trr.^2) - œá.*‚àÇŒ±.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + (1/2)*‚àÇŒ±.*‚àÇœá./Œ≥trr - œá.*‚àÇ2Œ±./Œ≥trr)

    ‚àÇtŒìr = (-v*Œ≤r.*((‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2)./Œ≥trr + Œ±.*Arr.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./(Œ≥trr.^2)
     - (1/3)*v*‚àÇŒ≤r.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr + ‚àÇŒ≤r.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + Œ≤r.*‚àÇŒìr + Œ±.*Arr.*‚àÇŒ≥trr./(Œ≥trr.^3)
     - (4/3)*Œ±.*‚àÇK./Œ≥trr - 2*Arr.*‚àÇŒ±./(Œ≥trr.^2) + (1/2)*v*‚àÇŒ≤r.*‚àÇŒ≥trr./(Œ≥trr.^2)
     - (1/2)*‚àÇŒ≤r.*‚àÇŒ≥trr./(Œ≥trr.^2) - 3*Œ±.*Arr.*(‚àÇœá./œá)./(Œ≥trr.^2)
     + (1/6)*v*Œ≤r.*‚àÇ2Œ≥trr./(Œ≥trr.^2) + (1/3)*v*Œ≤r.*(‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + (1/3)*v*‚àÇ2Œ≤r./Œ≥trr + ‚àÇ2Œ≤r./Œ≥trr)

    ‚àÇtA = ‚àÇtK

    ‚àÇtBr = c*(‚àÇtŒìr + b*Œ≤r.*‚àÇBr - b*Œ≤r.*‚àÇŒìr - Œ∑*Br)

    #########################################################
    # Source Terms and Source Evolution
    #
    # This currently includes the addition of source terms
    # to GR that come from a Klein-Gordon scalar field
    #
    #########################################################

    # Klein-Gordon System

    ‚àÇtùúô = Œ≤r.*‚àÇùúô - 2*Œ±.*Kùúô
    ‚àÇtKùúô = (Œ≤r.*‚àÇKùúô + Œ±.*K.*Kùúô - (1/2)*Œ±.*œá.*‚àÇ2ùúô./Œ≥trr
        + (1/4)*Œ±.*œá.*‚àÇŒ≥trr.*‚àÇùúô./Œ≥trr.^2 - (1/4)*Œ±.*‚àÇœá.*‚àÇùúô./Œ≥trr
        - (1/2)*œá.*‚àÇŒ±.*‚àÇùúô./Œ≥trr - (1/2)*œá.*‚àÇŒ≥tŒ∏Œ∏.*‚àÇùúô./(Œ≥trr.*Œ≥tŒ∏Œ∏)
        + (1/2)*‚àÇœá.*‚àÇùúô./(Œ≥trr) + (1/2)*m^2*ùúô)

    # Inverse metric (contravariant indices)

    gtt = -(1 ./Œ±.^2)
    gtr = Œ≤r./Œ±.^2
    grr = œá./Œ≥trr - (Œ≤r./Œ±).^2
    gŒ∏Œ∏ = œá./Œ≥tŒ∏Œ∏

    # Lagrangian Density for scalar field

    ùìõ = (1/2)*gtt.*‚àÇtùúô.^2 + (1/2)*grr.*‚àÇùúô.^2 + gtr.*‚àÇùúô.*‚àÇtùúô - (1/2)*(m^2)*ùúô.^2

    # Stresss Energy components (contravariant indices)

    Ttt = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).^2 - gtt.*ùìõ
    Trr = (gtr.*‚àÇtùúô + grr.*‚àÇùúô).^2 - grr.*ùìõ
    Ttr = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).*(gtr.*‚àÇtùúô + grr.*‚àÇùúô) - gtr.*ùìõ
    TŒ∏Œ∏ = -gŒ∏Œ∏.*ùìõ

    # Source Terms to GR
    # Sr here is a contravariant vector component
    # Srr here is a covariant tensor component

    œÅ = (Œ±.^2).*Ttt
    Sr = Œ±.*Ttr
    Srr = ((Œ≥trr.^2)./(œá.^2)).*Trr
    S = (Œ≥trr.*Trr + 2*Œ≥tŒ∏Œ∏.*TŒ∏Œ∏)./œá

    ‚àÇtArr .+= -8*pi*Œ±.*(œá.*Srr - (1/3)*S.*Œ≥trr)
    ‚àÇtK .+= 4*pi*Œ±.*(œÅ + S)
    ‚àÇtŒìr .+= -16*pi*Œ±.*Sr./œá

    # Convert back to regularized variables

    # ‚àÇtŒìreg = -(r/2).*‚àÇtŒìr
    # ‚àÇtŒ≥tŒ∏Œ∏reg = (1 ./r.^2).*‚àÇtŒ≥tŒ∏Œ∏

    ‚àÇtŒ≥tŒ∏Œ∏reg = (1 ./r.^2).*‚àÇtŒ≥tŒ∏Œ∏
    ‚àÇtArrreg = real((r .+ 0im).^(5/2)).*‚àÇtArr
    ‚àÇtKreg = real((r .+ 0im).^(3/2)).*‚àÇtK

    # Numerical Dissipation terms

    ‚àÇ4Œ± = dissipation(Œ±)
    ‚àÇ4A = dissipation(A)
    ‚àÇ4Œ≤r = dissipation(Œ≤r)
    ‚àÇ4Br = dissipation(Br)
    ‚àÇ4œá = dissipation(œá)
    ‚àÇ4Œ≥trr = dissipation(Œ≥trr)
    ‚àÇ4Œ≥tŒ∏Œ∏reg = dissipation(Œ≥tŒ∏Œ∏reg)
    ‚àÇ4Arrreg = dissipation(Arrreg)
    ‚àÇ4Kreg = dissipation(Kreg)
    ‚àÇ4Œìr = dissipation(Œìr)
    ‚àÇ4ùúô = dissipation(ùúô)
    ‚àÇ4Kùúô = dissipation(Kùúô)

    #sign = -1 seems the best
    sign = -1
    œÉ = 0.3

    # ‚àÇtŒ± .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ±
    # ‚àÇtŒ≤r .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≤r
    # ‚àÇtBr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Br
    # ‚àÇtœá .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6œá
    # ‚àÇtŒ≥trr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≥trr
    # ‚àÇtŒ≥tŒ∏Œ∏ .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≥tŒ∏Œ∏
    # ‚àÇtArr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Arr
    # ‚àÇtK .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6K
    # ‚àÇtŒìreg .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œìreg

    ‚àÇtŒ± .+= (1/(16))*sign*œÉ*(drt^3)*‚àÇ4Œ±
    ‚àÇtA .+= (1/(16))*sign*œÉ*(drt^3)*‚àÇ4A
    ‚àÇtŒ≤r .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≤r
    ‚àÇtBr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Br
    ‚àÇtœá .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4œá
    ‚àÇtŒ≥trr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≥trr
    ‚àÇtŒ≥tŒ∏Œ∏reg .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≥tŒ∏Œ∏reg
    ‚àÇtArrreg .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Arrreg
    ‚àÇtKreg .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Kreg
    ‚àÇtŒìr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œìr
    ‚àÇtùúô .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4ùúô
    ‚àÇtKùúô .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Kùúô

    # Inner temporal boundary Conditions

    ‚àÇtŒ±[1:2] .= 0.
    ‚àÇtA[1:2] .= 0.
    ‚àÇtŒ≤r[1:2] .= 0.
    ‚àÇtBr[1:2] .= 0.
    ‚àÇtœá[1:2] .= 0.
    ‚àÇtŒ≥trr[1:2] .= 0.
    ‚àÇtŒ≥tŒ∏Œ∏reg[1:2] .= 0.
    ‚àÇtArrreg[1:2] .= 0.
    ‚àÇtKreg[1:2] .= 0.
    ‚àÇtŒìr[1:2] .= 0.
    ‚àÇtùúô[1:2] .= 0.
    ‚àÇtKùúô[1:2] .= 0.

    # Outer temporal boundary conditions

    ‚àÇtŒ±[(n-1):n] .= 0.
    ‚àÇtA[(n-1):n] .= 0.
    ‚àÇtŒ≤r[(n-1):n] .= 0.
    ‚àÇtBr[(n-1):n] .= 0.
    ‚àÇtœá[(n-1):n] .= 0.
    ‚àÇtŒ≥trr[(n-1):n] .= 0.
    ‚àÇtŒ≥tŒ∏Œ∏reg[(n-1):n] .= 0.
    ‚àÇtArrreg[(n-1):n] .= 0.
    ‚àÇtKreg[(n-1):n] .= 0.
    ‚àÇtŒìr[(n-1):n] .= 0.
    ‚àÇtùúô[(n-1):n] .= 0.
    ‚àÇtKùúô[(n-1):n] .= 0.

    # In case you want to freeze all GR variables

    # ‚àÇtŒ±[2:(n-1)] .= 0.
    # ‚àÇtŒ≤r[2:(n-1)] .= 0.
    # ‚àÇtBr[2:(n-1)] .= 0.
    # ‚àÇtœá[2:(n-1)] .= 0.
    # ‚àÇtŒ≥trr[2:(n-1)] .= 0.
    # ‚àÇtŒ≥tŒ∏Œ∏reg[2:(n-1)] .= 0.
    # ‚àÇtArr[2:(n-1)] .= 0.
    # ‚àÇtK[2:(n-1)] .= 0.
    # ‚àÇtŒìreg[2:(n-1)] .= 0.

    #Values at infinity
    # Œ±0 = 1
    # Œ≤r0 = 0
    # Br0 = 0
    # œá0 = 1
    # grr0 = 1
    # gŒ∏Œ∏reg0 = 0
    # Arr0 = 0
    # K0 = 0
    # Œìreg0 = 1
    #
    # ‚àÇtŒ±[(n-1):n] .= (Œ±[(n-1):n] .- Œ±0)./r[(n-1):n] - ‚àÇŒ±[(n-1):n] + hŒ±./(r[(n-1):n].^w)
    # ‚àÇtŒ≤r[(n-1):n] .= (Œ≤r[(n-1):n] .- Œ≤r0)./r[(n-1):n] - ‚àÇŒ≤r[(n-1):n] + hŒ≤r./(r[(n-1):n].^w)
    # ‚àÇtBr[(n-1):n] .= (Br[(n-1):n] .- Br0)./r[(n-1):n] - ‚àÇBr[(n-1):n] + hBr./(r[(n-1):n].^w)
    # ‚àÇtœá[(n-1):n] .= (œá[(n-1):n] .- œá0)./r[(n-1):n] - ‚àÇœá[(n-1):n] + hœá./(r[(n-1):n].^w)
    # ‚àÇtgrr[(n-1):n] .= (grr[(n-1):n] .- grr0)./r[(n-1):n] - ‚àÇgrr[(n-1):n] + hgrr./(r[(n-1):n].^w)
    # ‚àÇtgŒ∏Œ∏reg[(n-1):n] .= (gŒ∏Œ∏reg[(n-1):n] .- gŒ∏Œ∏reg0)./r[(n-1):n] - ‚àÇgŒ∏Œ∏reg[(n-1):n] + hgŒ∏Œ∏reg./(r[(n-1):n].^w)
    # ‚àÇtArr[(n-1):n] .= (Arr[(n-1):n] .- Arr0)./r[(n-1):n] - ‚àÇArr[(n-1):n] + hArr./(r[(n-1):n].^w)
    # ‚àÇtK[(n-1):n] .= (K[(n-1):n] .- K0)./r[(n-1):n] - ‚àÇK[(n-1):n] + hK./(r[(n-1):n].^w)
    # ‚àÇtŒìreg[(n-1):n] .= (Œìreg[(n-1):n] .- Œìreg0)./r[(n-1):n] - ‚àÇŒìreg[(n-1):n] + hŒìreg./(r[(n-1):n].^w)

    return GBSSN_Variables(‚àÇtŒ±,‚àÇtA,‚àÇtŒ≤r,‚àÇtBr,‚àÇtœá,‚àÇtŒ≥trr,‚àÇtŒ≥tŒ∏Œ∏reg,‚àÇtArrreg,‚àÇtKreg,‚àÇtŒìr,‚àÇtùúô,‚àÇtKùúô)

end

function constraints(T,state::GBSSN_Variables,param)

    ############################################
    # Caculates the constraints of the system
    #
    # These are outputed at every saved time step.
    # They should limit to zero as the spatial
    # resolution is increased. They are important to
    # monitor to make sure the physics of the system
    # is being properly modeled.
    ############################################

    # Unpack Variables

    Œ± = state.Œ±
    Œ≤r = state.Œ≤r
    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arrreg = state.Arr
    Kreg = state.K
    Œìr = state.Œìr
    ùúô = state.ùúô
    Kùúô = state.Kùúô

    m = param[7]

    # Gauge conditions

    v = param[3]

    if v == 1 # Lagrangian Condition
        Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4] - 126*Œ≥tŒ∏Œ∏reg[5]
        + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    end

    # Spatial Derivatives

    order = 4

    # First derivatives
    ‚àÇrtœá = deriv(œá,order,1)
    ‚àÇrtŒ≥trr = deriv(Œ≥trr,order,1)
    ‚àÇrtŒ≥tŒ∏Œ∏reg = deriv(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇrtArrreg = deriv(Arrreg,order,1)
    ‚àÇrtKreg = deriv(Kreg,order,1)
    ‚àÇrtùúô = deriv(ùúô,order,1)

    # Second derivatives
    ‚àÇ2rtœá = deriv2(œá,order,1)
    ‚àÇ2rtŒ≥tŒ∏Œ∏reg = deriv2(Œ≥tŒ∏Œ∏reg,order,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    r = sample(Float64, œá.grid, param[4])
    drdrt = sample(Float64, œá.grid, param[5])
    d2rdrt = sample(Float64, œá.grid, param[6])

    ‚àÇœá = ‚àÇrtœá./drdrt
    ‚àÇŒ≥trr = ‚àÇrtŒ≥trr./drdrt
    ‚àÇŒ≥tŒ∏Œ∏reg = ‚àÇrtŒ≥tŒ∏Œ∏reg./drdrt
    ‚àÇArrreg = ‚àÇrtArrreg./drdrt
    ‚àÇKreg = ‚àÇrtKreg./drdrt
    ‚àÇùúô = ‚àÇrtùúô./drdrt

    ‚àÇ2œá = (‚àÇ2rtœá - d2rdrt.*‚àÇœá)./(drdrt.^2)
    ‚àÇ2Œ≥tŒ∏Œ∏reg = (‚àÇ2rtŒ≥tŒ∏Œ∏reg - d2rdrt.*‚àÇŒ≥tŒ∏Œ∏reg)./(drdrt.^2)

    ‚àÇtùúô = Œ≤r.*‚àÇùúô - 2*Œ±.*Kùúô

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇŒ≥tŒ∏Œ∏ = (r.^2).*‚àÇŒ≥tŒ∏Œ∏reg + (2*r).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇ2Œ≥tŒ∏Œ∏ = (r.^2).*‚àÇ2Œ≥tŒ∏Œ∏reg + (4*r).*‚àÇŒ≥tŒ∏Œ∏reg + 2*(Œ≥tŒ∏Œ∏reg .+ 1)

    K = real((r .+ 0im).^(-3/2)).*Kreg
    ‚àÇK = real((r .+ 0im).^(-3/2)).*‚àÇKreg - (3/2)*real((r .+ 0im).^(-5/2)).*Kreg

    Arr = real((r .+ 0im).^(-5/2)).*Arrreg
    ‚àÇArr = real((r .+ 0im).^(-5/2)).*‚àÇArrreg - (5/2)*real((r .+ 0im).^(-7/2)).*Arrreg

    # Œìr = -(2 ./r).*Œìreg

    # Inverse metric (contravariant indices)

    gtt = -(1 ./Œ±.^2)
    gtr = Œ≤r./Œ±.^2
    grr = œá./Œ≥trr - (Œ≤r./Œ±).^2
    gŒ∏Œ∏ = œá./Œ≥tŒ∏Œ∏

    # Lagrangian Density for scalar field

    ùìõ = (1/2)*gtt.*‚àÇtùúô.^2 + (1/2)*grr.*‚àÇùúô.^2 + gtr.*‚àÇùúô.*‚àÇtùúô - (1/2)*(m^2)*ùúô.^2

    # Stresss Energy components (contravariant indices)

    Ttt = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).^2 - gtt.*ùìõ
    Ttr = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).*(gtr.*‚àÇtùúô + grr.*‚àÇùúô) - gtr.*ùìõ

    # Source Terms to the constraints

    œÅ = (Œ±.^2).*Ttt
    Sr = Œ±.*Ttr

    # Constraint Equations

    ùìó = (-(3/2)*(Arr./Œ≥trr).^2 + (2/3)*K.^2 - (5/2)*((‚àÇœá.^2)./œá)./Œ≥trr
     + 2*‚àÇ2œá./Œ≥trr + 2*œá./Œ≥tŒ∏Œ∏ - 2*œá.*(‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr + 2*‚àÇœá.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + œá.*(‚àÇŒ≥trr./(Œ≥trr.^2)).*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏) - ‚àÇœá.*‚àÇŒ≥trr./(Œ≥trr.^2)
     + (1/2)*œá.*((‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2)./Œ≥trr - 16*pi*œÅ)

    ùìúr = (‚àÇArr./Œ≥trr - (2/3)*‚àÇK - (3/2)*Arr.*(‚àÇœá./œá)./Œ≥trr
     + (3/2)*Arr.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr - Arr.*‚àÇŒ≥trr./(Œ≥trr.^2)
     - 8*pi.*Œ≥trr.*Sr./œá)

    ùìñr = -(1/2)*‚àÇŒ≥trr./(Œ≥trr.^2) + Œìr + (‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr

    # ùìó[1:2] .= 0.
    # ùìúr[1:2] .= 0.
    # ùìñr[1:2] .= 0.

    return (ùìó, ùìúr, ùìñr, œÅ)

end

function horizon(T,state::GBSSN_Variables,param)

    ############################################
    # Caculates the apparent horizon
    #
    # Where the function crosses zero is the
    # apparent horizon of the black hole.
    ############################################

    v = param[3]

    # Unpack Variables

    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arrreg = state.Arr
    Kreg = state.K

    # Gauge condition

    # if v == 1 # Lagrangian Condition
    #     Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4] - 126*Œ≥tŒ∏Œ∏reg[5]
    #     + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    # end

    r = sample(T, œá.grid, param[4])
    drdrt = sample(T, œá.grid, param[5])

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)

    K = real((r .+ 0im).^(-3/2)).*Kreg

    Arr = real((r .+ 0im).^(-5/2)).*Arrreg

    # Intermediate calculations

    KŒ∏Œ∏ = ((1/3)*Œ≥tŒ∏Œ∏.*K - (1/2)*Arr.*Œ≥tŒ∏Œ∏./Œ≥trr)./œá

    grr =  Œ≥trr./œá

    gŒ∏Œ∏ =  Œ≥tŒ∏Œ∏./œá

    # Spatial Derivatives

    ‚àÇrtgŒ∏Œ∏ = deriv(gŒ∏Œ∏,4,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    ‚àÇgŒ∏Œ∏ = ‚àÇrtgŒ∏Œ∏./drdrt

    # Apparent horizon function

    Œò = (‚àÇgŒ∏Œ∏./gŒ∏Œ∏)./real((grr .+ 0im).^(1/2)) - 2*KŒ∏Œ∏./gŒ∏Œ∏

    # cross = GridFun(œá.grid, sign.(Œò))

    return Œò

end

# function crossings(Œò::GridFun)
#
#     GridFun(œá.grid, sign.(Œò))
#
#     for
#
# end


function custom_progress_message(dt,state,param,t)

    ###############################################
    # Outputs status numbers while the program runs
    ###############################################

    if param[1]==param[2]
        println("")
        println("| # | Time Step | Time | max Œ±'(t) | max œá'(t) | max Œ≥trr'(t) | max Œ≥tŒ∏Œ∏'(t) | max Arr'(t) | max K'(t) | max Œìr'(t) |")
        println("|___|___________|______|___________|___________|______________|______________|_____________|___________|____________|")
        println("")
    end

    derivstate = rhs(state,param,t)

    println("  ",
    rpad(string(param[1]),6," "),
    rpad(string(round(dt,digits=3)),10," "),
    rpad(string(round(t,digits=3)),10," "),
    rpad(string(round(maximum(abs.(derivstate.Œ±)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.œá)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.Œ≥trr)),digits=3)),14," "),
    rpad(string(round(maximum(abs.(derivstate.Œ≥tŒ∏Œ∏)),digits=3)),14," "),
    rpad(string(round(maximum(abs.(derivstate.Arr)),digits=3)),12," "),
    # rpad(string(round(maximum(abs.(derivstate.ùúô)),digits=3)),12," "),
    # rpad(string(round(maximum(abs.(derivstate.Kùúô)),digits=3)),14," ")
    rpad(string(round(maximum(abs.(derivstate.K)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.Œìr)),digits=3)),14," ")
    )

    #PrettyTables.jl

    param[1] += param[2]

end


function solution_saver(T,grid,sol,param,folder)

    ###############################################
    # Saves all of the variables in nice CSV files
    # in the choosen data folder directory
    ###############################################

    vars = (["Œ±","A","Œ≤r","Br","œá","Œ≥trr","Œ≥tŒ∏Œ∏","Arr","K","Œìreg","ùúô","Kùúô",
    "H","Mr","Gr","œÅ","‚àÇtŒ±","‚àÇtŒ≤r","‚àÇtBr","‚àÇtœá","‚àÇtŒ≥trr","‚àÇtŒ≥tŒ∏Œ∏",
    "‚àÇtArr","‚àÇtK","‚àÇtŒìreg","‚àÇtùúô","‚àÇtKùúô","appHorizon"])
    varlen = length(vars)
    #mkdir(string("data\\",folder))
    tlen = size(sol)[3]
    rlen = grid.ncells + 4
    loc = sample(T, grid, param[4])
    #loc[1] =
    cons = Array{GridFun,2}(undef,tlen,4)
    derivs = Array{GBSSN_Variables,1}(undef,tlen)
    apphorizon = Array{GridFun,1}(undef,tlen)

    for i in 1:tlen
        derivs[i] = rhs(sol[i],param,0)
        cons[i,1:4] .= constraints(T,sol[i],derivs[i],param)
        apphorizon[i] = horizon(T,sol[i],param)
    end


    array = Array{T,2}(undef,tlen+1,rlen+1)

    array[1,1] = 0
    array[1,2:end] .= loc

    for j = 1:varlen
        if j < 13
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= sol[:,j,i-1]
            end
        elseif j < 17
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= cons[i-1,j-12]
            end
        elseif j < 28
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= derivs[i-1][:,j-16]
            end
        else
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= apphorizon[i-1]
            end
        end

        CSV.write(
        string("data/",folder,"/",vars[j],".csv"),
        DataFrame(array, :auto),
        header=false
        )

    end

end

function main(points)

    ###############################################
    # Main Program
    #
    # Calls each of the above functions to run a
    # simulation. Sets up the numerical grid,
    # sets the gauge conditions, sets up a new
    # computational rt coordinate that makes the
    # physical r coordinate step larger near the
    # outer boundary, sets the initial conditions,
    # and finally runs the numerical DiffEq
    # package to run the time integration.
    #
    # All data is saved in the folder specified to
    # the solution_saver, each in their own CSV
    # file.
    ###############################################

    T = Float64
    rspan = T[1,210]
    rtspan = T[1,21]

    grid = setup(T, rtspan, points)
    drt = spacing(grid)
    dt = drt/4

    tspan = T[0,20]
    v = 1

    m = 0

    # f(b) = b*tan(rtspan[2]/b)-rspan[2]
    #
    # scale = find_zero(f, 0.64*rtspan[2])
    #
    # r(rt) = scale*tan(rt/scale)
    # drdrt(rt) = sec(rt/scale)^2
    # d2rdrt(rt) = (2/scale)*(sec(rt/scale)^2)*tan(rt/scale)

    r(rt) = rt
    drdrt(rt) = 1
    d2rdrt(rt) = 0

    atol = eps(T)^(T(3) / 4)
    alg = RK4()

    #printlogo()

    printtimes = 1
    custom_progress_step = round(Int, printtimes/dt)
    step_iterator = custom_progress_step
    param = [step_iterator, custom_progress_step, v, r, drdrt, d2rdrt, m]
    println("Defining Initial State...")
    #state = init(T, grid, param)::GBSSN_Variables
    println("Defining Problem...")
    #prob = ODEProblem(rhs, state, tspan, param)
    println("Starting Solution...")

    init(T, grid, param)

    # sol = solve(
    #     prob, alg,
    #     abstol = atol,
    #     dt = drt/4,
    #     adaptive = false,
    #     saveat = 1,
    #     progress = true,
    #     progress_steps=custom_progress_step,
    #     progress_message=custom_progress_message
    # )
    #
    # solution_saver(T,grid,sol,param,"ScalarTests")

end


end
