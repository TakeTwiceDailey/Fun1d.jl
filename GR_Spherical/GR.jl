module GR_Spherical

using DifferentialEquations
using BoundaryValueDiffEq
using OrdinaryDiffEq
using Fun1d
using DataFrames
using CSV
using Plots
using Roots

# using Random

struct GBSSN_Variables{S,T} <: AbstractArray{T,2}
    Œ±::GridFun{S,T}
    A::GridFun{S,T}
    Œ≤r::GridFun{S,T}
    Br::GridFun{S,T}
    œá::GridFun{S,T}
    Œ≥trr::GridFun{S,T}
    Œ≥tŒ∏Œ∏::GridFun{S,T}
    Arr::GridFun{S,T}
    K::GridFun{S,T}
    Œìr::GridFun{S,T}
    ùúô::GridFun{S,T}
    Kùúô::GridFun{S,T}
end

cont(x::GBSSN_Variables) = (x.Œ±, x.A, x.Œ≤r, x.Br, x.œá, x.Œ≥trr, x.Œ≥tŒ∏Œ∏, x.Arr, x.K, x.Œìr, x.ùúô, x.Kùúô)
numvar = 12

# Iteration
Base.IteratorSize(::Type{<:GBSSN_Variables}) = Iterators.HasShape{2}()
Base.eltype(::Type{GBSSN_Variables{S,T}}) where {S,T} = T
Base.isempty(x::GBSSN_Variables) = isempty(x.Œ±)
function Base.iterate(x::GBSSN_Variables, state...)
    return iterate(Iterators.flatten(cont(x)), state...)
end
Base.size(x::GBSSN_Variables) = (length(x.Œ±), numvar)
Base.size(x::GBSSN_Variables, d) = size(x)[d]

# Indexing
function lin2cart(x::GBSSN_Variables, i::Number)
    n = length(x.Œ±)
    return (i - 1) % n + 1, (i - 1) √∑ n + 1
end
Base.firstindex(x::GBSSN_Variables) = error("not implemented")
Base.getindex(x::GBSSN_Variables, i) = getindex(x, i.I...)
Base.getindex(x::GBSSN_Variables, i::Number) = getindex(x, lin2cart(x, i)...)
Base.getindex(x::GBSSN_Variables, i, j) = getindex(cont(x)[j], i)
Base.lastindex(x::GBSSN_Variables) = error("not implemented")
Base.setindex!(x::GBSSN_Variables, v, i) = setindex!(x, v, i.I...)
Base.setindex!(x::GBSSN_Variables, v, i::Number) = setindex!(x, v, lin2cart(x, i))
Base.setindex!(x::GBSSN_Variables, v, i, j) = setindex!(cont(x)[j], v, i)

# Abstract Array
Base.IndexStyle(::GBSSN_Variables) = IndexCartesian()
Base.similar(x::GBSSN_Variables) = GBSSN_Variables(map(similar, cont(x))...)
function Base.similar(x::GBSSN_Variables, ::Type{T}) where {T}
    return GBSSN_Variables(map(y -> similar(y,T), cont(x))...)
end
Base.similar(x::GBSSN_Variables, ::Dims) = similar(x)
Base.similar(x::GBSSN_Variables, ::Dims, ::Type{T}) where {T} = similar(x, T)

# Broadcasting
Base.BroadcastStyle(::Type{<:GBSSN_Variables}) = Broadcast.ArrayStyle{GBSSN_Variables}()
function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{GBSSN_Variables}},
                      ::Type{T}) where {T}
    x = find_GBSSN_Variables(bc)
    return similar(x, T)
end
find_GBSSN_Variables(bc::Base.Broadcast.Broadcasted) = find_GBSSN_Variables(bc.args)
find_GBSSN_Variables(args::Tuple) = find_GBSSN_Variables(find_GBSSN_Variables(args[1]), Base.tail(args))
find_GBSSN_Variables(x) = x
find_GBSSN_Variables(::Tuple{}) = nothing
find_GBSSN_Variables(a::GBSSN_Variables, rest) = a
find_GBSSN_Variables(::Any, rest) = find_GBSSN_Variables(rest)

# Others
function Base.map(fun, x::GBSSN_Variables, ys::GBSSN_Variables...)
    return GBSSN_Variables(
        map(fun, x.Œ±, (y.Œ± for y in ys)...),
        map(fun, x.A, (y.A for y in ys)...),
        map(fun, x.Œ≤r, (y.Œ≤r for y in ys)...),
        map(fun, x.Br, (y.Br for y in ys)...),
        map(fun, x.œá, (y.œá for y in ys)...),
        map(fun, x.Œ≥trr, (y.Œ≥trr for y in ys)...),
        map(fun, x.Œ≥tŒ∏Œ∏, (y.Œ≥tŒ∏Œ∏ for y in ys)...),
        map(fun, x.Arr, (y.Arr for y in ys)...),
        map(fun, x.K, (y.K for y in ys)...),
        map(fun, x.Œìr, (y.Œìr for y in ys)...),
        map(fun, x.ùúô, (y.ùúô for y in ys)...),
        map(fun, x.Kùúô, (y.Kùúô for y in ys)...)
        )
end

# function Base.rand(rng::AbstractRNG, ::Random.SamplerType{GBSSN_Variables{T}}) where {T}
#     return GBSSN_Variables{T}(rand(rng, T), rand(rng, T))
# end

Base.zero(::Type{<:GBSSN_Variables}) = error("not implemented")
Base.zero(x::GBSSN_Variables) = GBSSN_Variables(map(zero, cont(x))...)

Base.:+(x::GBSSN_Variables) = map(+, x)
Base.:-(x::GBSSN_Variables) = map(-, x)

Base.:+(x::GBSSN_Variables, y::GBSSN_Variables) = map(+, x, y)
Base.:-(x::GBSSN_Variables, y::GBSSN_Variables) = map(-, x, y)

Base.:*(x::GBSSN_Variables, a::Number) = map(b -> b * a, x)
Base.:*(a::Number, x::GBSSN_Variables) = map(b -> a * b, x)
Base.:/(x::GBSSN_Variables, a::Number) = map(b -> b / a, x)
Base.:\(a::Number, x::GBSSN_Variables) = map(b -> a \ b, x)

################################################################################

function printlogo()
    # Just a fancy ASCII logo for the program
    println(
"\n",
"           /\\\\\\\\\\\\\\\\\\       /\\\\\\\\\\\\\\\\\\\\\\\\\n",
" ________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/ /\\\\\\\\/ / /\\\\\\\\_____________________________\n",
"  ______//\\\\\\\\\\/ / / / /___\\/ /\\\\\\\\/_/ / /\\\\\\\\___________________________\n",
"   _____//\\\\\\\\/_/_/_/_/_____\\/ /\\\\\\\\ \\/ / /\\\\\\\\___________________________\n",
"    ____/ /\\\\\\\\____/\\\\\\\\\\\\___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\\\\\_______in___________________\n",
"     ___\\/ /\\\\\\\\__/ /  /\\\\\\___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\/________Spherical____________\n",
"      ___\\/ /\\\\\\\\_\\/__/ /\\\\\\___\\/ /\\\\\\\\ / /\\\\\\\\__________Symmetry____________\n",
"       ___\\/ /\\\\\\\\____\\/ /\\\\\\___\\/ /\\\\\\\\_/ //\\\\\\\\_____________________________\n",
"        ___\\/ /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\/ /\\\\\\\\\\// //\\\\\\\\____________________________\n",
"         ___\\/ / /\\\\\\\\\\\\\\\\\\  /____\\/ /\\\\\\\\_\\// //\\\\\\\\_____by Erik Schnetter_____\n",
"          ___\\/_/ / / / / /_/______\\/ /  /___\\// /  /_______and Conner Dailey____\n",
"           _____\\/_/_/_/_/__________\\/__/______\\/__/______________________________\n"
)

end

function setup(::Type{S}, rspan, points::Int) where {S}

    # Specify the radial domain and the
    # radial step amount and make a Grid object
    rmin,rmax = rspan
    domain = Domain{S}(rmin, rmax)
    grid = Grid(domain, points)
    return grid

end

function dissipation(f::GridFun{S,T}) where {S,T}

    ############################################
    # Calculates the numerical dissipation terms
    #
    # Finite differencing fails to model high
    # frequency modes in the system, and these
    # modes can lead to instabilities. Adding
    # numerical dissipation terms damps these
    # high frequency modes by subtracting off
    # a high order derivative from each dynamical
    # variable in the system.
    ############################################

    dx = spacing(f.grid)
    n = f.grid.ncells + 4
    dvalues = Array{T}(undef, n)

    # if f.values[2] == 0.
    #     dvalues[3:6] .= ((f.values[3] - 6*f.values[4] + 15*f.values[5]
    #     - 20*f.values[6] + 15*f.values[7] - 6*f.values[8] + f.values[9])/(dx^6))
    # else
    #     dvalues[3:6] .= ((f.values[2] - 6*f.values[3] + 15*f.values[4]
    #     - 20*f.values[5] + 15*f.values[6] - 6*f.values[7] + f.values[8])/(dx^6))
    # end
    #
    # for i in 7:(n - 5)
    #     dvalues[i] =  ((f.values[i-3] - 6*f.values[i-2] + 15*f.values[i-1]
    #     - 20*f.values[i] + 15*f.values[i+1] - 6*f.values[i+2] + f[i+3])/(dx^6))
    # end
    #
    # dvalues[(n-4):(n-2)] .= ((f.values[n-8] - 6*f.values[n-7] + 15*f.values[n-6]
    # - 20*f.values[n-5] + 15*f.values[n-4] - 6*f.values[n-3] + f.values[n-2])/(dx^6))

    # if f.values[2] == 0.
    #     for i in 3:4
    #         dvalues[i] = ((f.values[i] - 4*f.values[i+1] + 6*f.values[i+2]
    #         - 4*f.values[i+3] + f.values[i+4])/(dx^4))
    #     end
    # else
    #     dvalues[3:4] .= ((f.values[2] - 4*f.values[3] + 6*f.values[4]
    #     - 4*f.values[5] + f.values[6])/(dx^4))
    # end

    # dvalues[1:4] .= 0.
    # # dvalues[3] = ((6*f.values[1] + 15*f.values[2]
    # # - 20*f.values[3] + 15*f.values[4] - 6*f.values[5]
    # # + f.values[6])/(dx^6))
    #
    # for i in 3:3
    #     dvalues[i] = ((f.values[i-2] - 4*f.values[i-1] + 6*f.values[i]
    #     - 4*f.values[i+1] + f.values[i+2])/(dx^4))
    # end
    # for i in 4:(n - 5)
    #     dvalues[i] = ((-f.values[i-3] + 12*f.values[i-2] -39*f.values[i-1]
    #     + 56*f.values[i] - 39*f.values[i+1] + 12*f.values[i+2]
    #     - f.values[i+3])/(dx^4))
    # end
    # dvalues[(n-4):n] .= 0.

    dvalues[1:2] .= 0.
    for i in 3:(n - 4)
        dvalues[i] = ((f.values[i-2] - 4*f.values[i-1] + 6*f.values[i]
        - 4*f.values[i+1] + f.values[i+2])/(dx^4))
    end
    dvalues[(n-3):n] .= 0.

    return GridFun(f.grid, dvalues)
end

function init(::Type{T}, grid::Grid, param) where {T}

    ############################################
    # Specifies the Initial Conditions
    ############################################

    n = grid.ncells + 4
    domain = grid.domain
    initgrid = grid
    drt = spacing(grid)
    r = param[4]
    drdrt = param[5]
    d2rdrt = param[6]
    m = param[7]
    rtspan = param[8]

    num = 0

    # Initial conditions for Schwarzschild metric (Ker-Schild Coordinates)

    # Mass (no real reason not to use 1 here)
    #M = 1

    fŒ±(M,rt) = real((1+2*M/(r(rt))+0im)^(-1/2))
    fA(rt) = 0.
    fŒ≤r(M,rt) = (2*M/r(rt))*fŒ±(M,rt)^2
    fBr(rt) = 0.
    fœá(rt) = 1.
    fŒ≥trr(M,rt) = 1+2*M/r(rt)
    fŒ≥tŒ∏Œ∏(rt) = r(rt)^2
    fArr(M,‚àÇM,rt) = (4/3)*(r(rt)*(M+r(rt))*‚àÇM-M*(3*M+2*r(rt)))/real(((r(rt)^5)*(r(rt)+2*M)+0im)^(1/2))
    fK(M,‚àÇM,rt) = (2*M*(3*M+r(rt))+2*r(rt)*‚àÇM*(M+r(rt)))/real((r(rt)*(r(rt)+2*M)+0im)^(3/2))
    fŒìr(M,‚àÇM,rt) = (r(rt)*‚àÇM-2*r(rt)-5*M)/(r(rt)+2*M)^2

    # fArr(M,rt) = -(4*M/3)*(3*M+2*r(rt))/real(((r(rt)^5)*(r(rt)+2*M)+0im)^(1/2))
    # fK(M,rt) = (2*M)*(3*M+r(rt))/real((r(rt)*(r(rt)+2*M)+0im)^(3/2))
    # fŒìr(M,rt) = -(2*r(rt)+5*M)/(r(rt)+2*M)^2

    r0 = 10.
    œÉr = 0.5
    #Amp = 1.
    Amp = 0*0.05

    fùúô(rt) = Amp*(1/r(rt))*exp(-(1/2)*((r(rt)-r0)/œÉr)^2)
    f‚àÇùúô(rt) = Amp*exp(-(1/2)*((r(rt)-r0)/œÉr)^2)*(r(rt)*r0-r(rt)^2-œÉr^2)/(r(rt)^2*œÉr^2)
    #f‚àÇtùúô(rt) = Amp*exp(-(1/2)*((r(rt)-r0)/œÉr)^2)*(r0-r(rt))/(r(rt)*œÉr^2)
    fKùúô(rt) = 0.

    f‚àÇœá(rt) = 0.
    f‚àÇŒ≥trr(M,‚àÇM,rt) = 2*(r(rt)*‚àÇM-M)/(r(rt)^2)
    f‚àÇŒ≥tŒ∏Œ∏(rt) = 2*r(rt)
    # f‚àÇArr(M,rt) = (4*M/3)*(15*M^2+15*M*r(rt)+4*r(rt)^2)/real(((r(rt)^7)*((r(rt)+2*M)^3)+0im)^(1/2))
    # f‚àÇK(M,rt) = -2*M*(9*M^2+10*M*r(rt)+2*r(rt)^2)/real((r(rt)*(r(rt)+2*M)+0im)^(5/2))
    # f‚àÇŒìr(M,rt) = 2*(r(rt)+3*M)/(r(rt)+2*M)^3
    #
    f‚àÇ2Œ≥tŒ∏Œ∏(rt) = 2.
    f‚àÇ2œá(rt) = 0.

    # fgtt(M,rt) = -(1/fŒ±(M,rt)^2)
    # fgtr(M,rt) = fŒ≤r(M,rt)/fŒ±(M,rt)^2
    # fgrr(M,œá,rt) = œá/fŒ≥trr(M,rt) - (fŒ≤r(M,rt)/fŒ±(M,rt))^2
    #
    # # Lagrangian Density for scalar field
    #
    # fùìõ(M,œá,rt) = ((1/2)*fgtt(M,rt)*f‚àÇtùúô(rt)^2 + (1/2)*fgrr(M,œá,rt)*f‚àÇùúô(rt)^2
    #  + fgtr(M,rt)*f‚àÇùúô(rt)*f‚àÇtùúô(rt) - (1/2)*(m^2)*fùúô(rt)^2)
    #
    # # Stresss Energy components (contravariant indices)
    #
    # fTtt(M,œá,rt) = (fgtt(M,rt)*f‚àÇtùúô(rt) + fgtr(M,rt)*f‚àÇùúô(rt)).^2 - fgtt(M,rt)*fùìõ(M,œá,rt)
    # fTtr(M,œá,rt) = ((fgtt(M,rt)*f‚àÇtùúô(rt) + fgtr(M,rt)*f‚àÇùúô(rt))*(fgtr(M,rt)*f‚àÇtùúô(rt)
    #  + fgrr(M,œá,rt)*f‚àÇùúô(rt)) - fgtr(M,rt)*fùìõ(M,œá,rt))

    #fKùúô(rt) = -(f‚àÇtùúô(rt) - fŒ≤r(rt)*f‚àÇùúô(rt))/(2*fŒ±(M,rt))

    fœÅ(M,rt) = (2*fKùúô(rt)^2 + (1/2)*(fœá(rt)/fŒ≥trr(M,rt))*f‚àÇùúô(rt)^2
        + (1/2)*m^2*fùúô(rt)^2)

    fSr(rt) = 2*fKùúô(rt)*f‚àÇùúô(rt)

    #f‚àÇœá(rt,(œá, ‚àÇœá, M)) = ‚àÇœá

    # function f‚àÇ2œá(rt,(œá, X, Arr))
    #  -(1/2)*fŒ≥trr(rt)*(-(3/2)*(Arr/fŒ≥trr(rt))^2 + (2/3)*fK(rt)^2
    #  - (5/2)*((X^2)/œá)/fŒ≥trr(rt)
    #  + 2*œá/fŒ≥tŒ∏Œ∏(rt) - 2*œá*(f‚àÇ2Œ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt)
    #  + 2*X*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt)
    #  + œá*(f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2))*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))
    #  - X*f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2)
    #  + (1/2)*œá*((f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))^2)/fŒ≥trr(rt) - 16*pi*fœÅ(rt,œá))
    # end
    #
    # function f‚àÇArr(rt,(œá, X, Arr))
    #  -fŒ≥trr(rt)*(-(2/3)*f‚àÇK(rt) - (3/2)*Arr*(X/œá)/fŒ≥trr(rt)
    #  + (3/2)*Arr*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt) - Arr*f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2)
    #  - 8*pi*fŒ≥trr(rt)*fSr(rt,œá)/œá)
    # end

    f‚àÇM(M,rt) = 4*pi*(r(rt)^2)*fœÅ(M,rt)

    function fùìó(M,‚àÇM,rt)
         (-(3/2)*(fArr(M,‚àÇM,rt)/fŒ≥trr(M,rt))^2 + (2/3)*fK(M,‚àÇM,rt)^2
         - (5/2)*((f‚àÇœá(rt)^2)/fœá(rt))/fŒ≥trr(M,rt) + 2*f‚àÇ2œá(rt)/fŒ≥trr(M,rt)
         + 2*fœá(rt)/fŒ≥tŒ∏Œ∏(rt) - 2*fœá(rt)*(f‚àÇ2Œ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(M,rt)
         + 2*f‚àÇœá(rt)*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(M,rt)
         + fœá(rt)*(f‚àÇŒ≥trr(M,‚àÇM,rt)/(fŒ≥trr(M,rt)^2))*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))
         - f‚àÇœá(rt)*f‚àÇŒ≥trr(M,‚àÇM,rt)/(fŒ≥trr(M,rt)^2)
         + (1/2)*fœá(rt)*((f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))^2)/fŒ≥trr(M,rt) - 16*pi*fœÅ(M,rt))
    end

    # function fùìúr(M,‚àÇM,rt)
    #  (f‚àÇArr(M,‚àÇM,rt)/fŒ≥trr(rt) - (2/3)*f‚àÇK(rt) - (3/2)*fArr(rt)*(f‚àÇœá(rt)/fœá(rt))/fŒ≥trr(rt)
    #  + (3/2)*fArr(rt)*(f‚àÇŒ≥tŒ∏Œ∏(rt)/fŒ≥tŒ∏Œ∏(rt))/fŒ≥trr(rt) - fArr(rt)*f‚àÇŒ≥trr(rt)/(fŒ≥trr(rt)^2)
    #  - 8*pi*fŒ≥trr(rt)*fSr(rt,fœá(rt))/fœá(rt))
    # end

    # grid = Grid(domain,Int((2^num)*(n-5)+1))
    # n = grid.ncells + 4

    # ‚àÇœá = sample(T, grid, rt->0)
    # ‚àÇŒ≥trr = sample(T, grid, f‚àÇŒ≥trr)
    # ‚àÇŒ≥tŒ∏Œ∏ = sample(T, grid, f‚àÇŒ≥tŒ∏Œ∏)
    # ‚àÇK = sample(T, grid, f‚àÇK)
    #‚àÇArr = sample(T, grid, rt->(4*M/3)*(15*M^2+15*M*r(rt)+4*r(rt)^2)/real(((r(rt)^7)*((r(rt)+2*M)^3)+0im)^(1/2)))

    # ‚àÇ2Œ≥tŒ∏Œ∏ = sample(T, grid, f‚àÇ2Œ≥tŒ∏Œ∏)
    #
    # order = 4
    #
    # rr = sample(T, grid, param[4])
    # drdrt = sample(Float64, grid, param[5])
    #
    # ‚àÇrtùúô = deriv(ùúô,order,1)
    # ‚àÇùúô = ‚àÇrtùúô./drdrt

    # fArrreg(M,‚àÇM,rt) = real((r(rt)+ 0im)^(5/2))*fArr(M,‚àÇM,rt)
    # fKreg(M,‚àÇM,rt) = real((r(rt)+ 0im)^(3/2))*fK(M,‚àÇM,rt)

    # Constraint Equations

    rtspan = (rtspan[1], rtspan[2])
    #rtspan = (rtspan[2], 0.5)

    function constraintSystem(M, param, rt)
        f‚àÇM(M,rt)
    end

    # function boundaryCondition!(residual, M, param, rt)
    #     residual = M[1] - 1. #inner boundary condition
    # end

    atol = 1e-15

    BVP = ODEProblem(constraintSystem, 1., rtspan, param)
    M = solve(BVP, Tsit5(), abstol=atol, dt=drt, adaptive=false)

    ‚àÇM(rt) = f‚àÇM(M(rt),rt)

    # M(rt) = 1.
    # ‚àÇM(rt) = 0.

    Œ± = sample(T, grid, rt -> fŒ±(M(rt),rt) )
    A = sample(T, grid, fA)
    Œ≤r = sample(T, grid, rt -> fŒ≤r(M(rt),rt) )
    Br = sample(T, grid, fBr)
    œá = sample(T, grid, fœá)
    Œ≥trr = sample(T, grid, rt -> fŒ≥trr(M(rt),rt) )
    Œ≥tŒ∏Œ∏reg = sample(T, grid, rt -> 0)
    Arr = sample(T, grid, rt -> fArr(M(rt),‚àÇM(rt),rt) )
    K = sample(T, grid, rt -> fK(M(rt),‚àÇM(rt),rt) )
    Œìr = sample(T, grid, rt -> fŒìr(M(rt),‚àÇM(rt),rt))
    ùúô = sample(T, grid, fùúô)
    Kùúô = sample(T, grid, fKùúô)

    # ‚àÇùúô = sample(T, grid, f‚àÇùúô)
    # ‚àÇtùúô = sample(T, grid, f‚àÇtùúô)
    #
    # Kùúô = -(‚àÇtùúô - Œ≤r.*‚àÇùúô)./(2*Œ±)
    #

    state = GBSSN_Variables(Œ±, A, Œ≤r, Br, œá, Œ≥trr, Œ≥tŒ∏Œ∏reg, Arr, K, Œìr, ùúô, Kùúô)

    #
    #cons = constraints(T,state,param)

    #println(f‚àÇM(14.,(1., 0., 1.)))
    #println(f‚àÇ2œá(14.,(1., 0., 1.)))

    #rr = sample(T, grid, param[4])
    # ùìó = sample(T, grid, fùìó)
    # ùìúr = sample(T, grid, fùìúr)
    #
    # ‚àÇ2œá = sample(T, grid, rt -> f‚àÇArr(rt,(1, 0, fArr(rt)))-f‚àÇArr(rt))
    #
    #println(œá[1:10].-1)
    # println(œá[n-10:n].-1)
    #
    # temp1 = sample(T, grid, rt -> solution(rt)[3]-0*fArr(rt))
    #temp = sample(T, grid, rt -> fùìó(M(rt),‚àÇM(rt),rt))
    #temp = sample(T, grid, rt -> M(rt))

    #plot(rr[5:n-2],temp[5:n-2])
    #plot!(rr[5:n-2],temp1[5:n-2])

    #plot(solution, vars=(0,1))
    #println(temp[1:10])
    #println(temp[n-15:n-5])


    #plot(rr[5:n-4],cons[1][5:n-4])

    return state

end


function rhs(state::GBSSN_Variables, param, t)

    ############################################
    # Caculates the right hand ride of the
    # evolved variables
    #
    # This is the main meat of the program.
    # This function contains all of the boundary
    # conditions, coordinate conversions,
    # spatial derivative calculations,
    # evolution equations, and numerical
    # dissipation. Each time the Julia DiffEq
    # Solver moves one time step, it calls
    # this function to calculate the new
    # values of the evolved variables.
    ############################################

    # Unpack the Variables

    Œ± = state.Œ±
    A = state.A
    Œ≤r = state.Œ≤r
    Br = state.Br
    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arr = state.Arr
    K = state.K
    Œìr = state.Œìr
    ùúô = state.ùúô
    Kùúô =state.Kùúô

    drt = spacing(Œ±.grid)
    n = Œ±.grid.ncells + 4

    m = param[7]

    # Boundary Conditions

    # These inner boundary conditions are necessary for stable
    # evolution for the specified gauge condition and do not
    # specify anything physical about the system.

    # Eulerian/Lagrangian condition (0/1)
    v = param[3]

    # if v == 0 # Eulerian Condition
    #     Œ≤r[2] = (17*Œ≤r[3] + 9*Œ≤r[4] - 5*Œ≤r[5] + Œ≤r[6])/22
    # elseif v == 1 # Lagrangian Condition
    #     Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4]
    #     - 126*Œ≥tŒ∏Œ∏reg[5] + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    #     #Œ≤r[2] = (-315*Œ≤r[3] + 210*Œ≤r[4] - 126*Œ≤r[5] + 45*Œ≤r[6] - 7*Œ≤r[7])/63
    # end

    # Spatial Derivatives (finite differences) with respect to coordinate rt

    # Accuarcy order, 2 for 2nd order, 4 for 4th order
    order = 4

    # First derivatives
    ‚àÇrtŒ± = deriv(Œ±,order,1)
    ‚àÇrtA = deriv(A,order,1)
    ‚àÇrtŒ≤r = deriv(Œ≤r,order,-1)
    ‚àÇrtBr = deriv(Br,order,-1)
    ‚àÇrtœá = deriv(œá,order,1)
    ‚àÇrtŒ≥trr = deriv(Œ≥trr,order,1)
    ‚àÇrtŒ≥tŒ∏Œ∏reg = deriv(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇrtArr = deriv(Arr,order,1)
    ‚àÇrtK = deriv(K,order,1)
    ‚àÇrtŒìr = deriv(Œìr,order,-1)
    ‚àÇrtùúô = deriv(ùúô,order,1)
    ‚àÇrtKùúô = deriv(Kùúô,order,-1)

    # Second derivatives
    ‚àÇ2rtŒ± = deriv2(Œ±,order,1)
    ‚àÇ2rtŒ≤r = deriv2(Œ≤r,order,-1)
    ‚àÇ2rtœá = deriv2(œá,order,1)
    ‚àÇ2rtŒ≥trr = deriv2(Œ≥trr,order,1)
    ‚àÇ2rtŒ≥tŒ∏Œ∏reg = deriv2(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇ2rtùúô = deriv2(ùúô,order,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    r = sample(Float64, Œ±.grid, param[4])
    drdrt = sample(Float64, Œ±.grid, param[5])
    d2rdrt = sample(Float64, Œ±.grid, param[6])

    ‚àÇŒ± = ‚àÇrtŒ±./drdrt
    ‚àÇA = ‚àÇrtA./drdrt
    ‚àÇŒ≤r = ‚àÇrtŒ≤r./drdrt
    ‚àÇBr = ‚àÇrtBr./drdrt
    ‚àÇœá = ‚àÇrtœá./drdrt
    ‚àÇŒ≥trr = ‚àÇrtŒ≥trr./drdrt
    ‚àÇŒ≥tŒ∏Œ∏reg = ‚àÇrtŒ≥tŒ∏Œ∏reg./drdrt
    ‚àÇArr = ‚àÇrtArr./drdrt
    ‚àÇK = ‚àÇrtK./drdrt
    ‚àÇŒìr = ‚àÇrtŒìr./drdrt
    ‚àÇùúô = ‚àÇrtùúô./drdrt
    ‚àÇKùúô = ‚àÇrtKùúô./drdrt

    ‚àÇ2Œ± = (‚àÇ2rtŒ± - d2rdrt.*‚àÇŒ±)./(drdrt.^2)
    ‚àÇ2Œ≤r = (‚àÇ2rtŒ≤r - d2rdrt.*‚àÇŒ≤r)./(drdrt.^2)
    ‚àÇ2œá = (‚àÇ2rtœá - d2rdrt.*‚àÇœá)./(drdrt.^2)
    ‚àÇ2Œ≥trr = (‚àÇ2rtŒ≥trr - d2rdrt.*‚àÇŒ≥trr)./(drdrt.^2)
    ‚àÇ2Œ≥tŒ∏Œ∏reg = (‚àÇ2rtŒ≥tŒ∏Œ∏reg - d2rdrt.*‚àÇŒ≥tŒ∏Œ∏reg)./(drdrt.^2)
    ‚àÇ2ùúô = (‚àÇ2rtùúô - d2rdrt.*‚àÇùúô)./(drdrt.^2)

    # r[1:2] .= 0.
    # Œ≤r[1:2] .= 0.
    # Œ≥tŒ∏Œ∏reg[1:2] .= 0.
    # Œìr[1:2] .= 0.

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇŒ≥tŒ∏Œ∏ = (r.^2).*‚àÇŒ≥tŒ∏Œ∏reg + (2*r).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇ2Œ≥tŒ∏Œ∏ = (r.^2).*‚àÇ2Œ≥tŒ∏Œ∏reg + (4*r).*‚àÇŒ≥tŒ∏Œ∏reg + 2*(Œ≥tŒ∏Œ∏reg .+ 1)

    # Œ≥tŒ∏Œ∏[1:2] .= 0.
    # ‚àÇŒ≥tŒ∏Œ∏[1:2] .= 0.
    # ‚àÇ2Œ≥tŒ∏Œ∏[1:2] .= 0.

    # K = real((r .+ 0im).^(-3/2)).*Kreg
    # ‚àÇK = real((r .+ 0im).^(-3/2)).*‚àÇKreg - (3/2)*real((r .+ 0im).^(-5/2)).*Kreg
    #
    # Arr = real((r .+ 0im).^(-5/2)).*Arrreg
    # ‚àÇArr = real((r .+ 0im).^(-5/2)).*‚àÇArrreg - (5/2)*real((r .+ 0im).^(-7/2)).*Arrreg

    # Œìr = -(2 ./r).*Œìreg
    # ‚àÇŒìr = -(2 ./r).*‚àÇŒìreg + (2 ./(r.^2)).*Œìreg

    # Œìr = Œìreg
    # ‚àÇŒìr = ‚àÇŒìreg

    # Gauge Conditions

    # Coordinate drift parameter.
    # Positive values lead to continued evolution
    # zero gives eventual steady state
    Œ∑ = 0

    #Superscript condition...1 is a plus, 0 is a minus
    a = 0

    #Subscript condition...1 is a plus, 0 is a minus
    b = 0

    # Zero condition, 1 includes shift, 0 for vanishing shift
    # if this is 0, a and b don't matter as long as the
    # initial shift is zero
    c = 1

    #########################################################
    # Evolution Equations
    #
    # This is the full suite of evolution equations
    # for GR in spherical symmetry in the BSSN framework.
    # I have tried to keep them looking as close to their
    # mathematically written counterpart as possible.
    #
    # They are written in the order they appear in the
    # reference (arXiv:0705.3845v2) except for the ‚àÇtBr
    # equation since it contains a ‚àÇtŒìr term.
    #
    #########################################################

    ‚àÇtŒ± = a*Œ≤r.*‚àÇŒ± - 2*Œ±.*A

    ‚àÇtŒ≤r = c*((3/4)*Br + b*Œ≤r.*‚àÇŒ≤r)

    ‚àÇtœá = ((2/3)*K.*Œ±.*œá - (1/3)*v*Œ≤r.*œá.*‚àÇŒ≥trr./Œ≥trr - (2/3)*v*Œ≤r.*œá.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏
     - (2/3)*v*œá.*‚àÇŒ≤r + Œ≤r.*‚àÇœá)

    ‚àÇtŒ≥trr = (-2*Arr.*Œ± - (1/3)*v*Œ≤r.*‚àÇŒ≥trr + Œ≤r.*‚àÇŒ≥trr
     - (2/3)*v*Œ≥trr.*Œ≤r.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ + 2*Œ≥trr.*‚àÇŒ≤r - (2/3)*v*Œ≥trr.*‚àÇŒ≤r)

    ‚àÇtŒ≥tŒ∏Œ∏ = (Arr.*Œ≥tŒ∏Œ∏.*Œ±./Œ≥trr - (1/3)*v*Œ≥tŒ∏Œ∏.*Œ≤r.*‚àÇŒ≥trr./Œ≥trr - (2/3)*v*Œ≤r.*‚àÇŒ≥tŒ∏Œ∏
     + Œ≤r.*‚àÇŒ≥tŒ∏Œ∏ - (2/3)*v*Œ≥tŒ∏Œ∏.*‚àÇŒ≤r)

    ‚àÇtArr = (-2*Œ±.*(Arr.^2)./Œ≥trr + K.*Œ±.*Arr - (1/3)*v*Œ≤r.*Arr.*‚àÇŒ≥trr./Œ≥trr
     - (2/3)*v*Œ≤r.*Arr.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (2/3)*v*Arr.*‚àÇŒ≤r + 2*Arr.*‚àÇŒ≤r
     + (2/3)*Œ±.*œá.*(‚àÇŒ≥trr./Œ≥trr).^2 - (1/3)*Œ±.*œá.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2
     - (1/6)*Œ±.*(‚àÇœá.^2)./œá - (2/3)*Œ±.*œá.*Œ≥trr./Œ≥tŒ∏Œ∏ + Œ≤r.*‚àÇArr
     + (2/3)*Œ±.*œá.*Œ≥trr.*‚àÇŒìr - (1/2)*Œ±.*œá.*(‚àÇŒ≥trr./Œ≥trr).*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)
     + (1/3)*œá.*‚àÇŒ≥trr.*‚àÇŒ±./Œ≥trr + (1/3)*œá.*‚àÇŒ±.*‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (1/6)*Œ±.*‚àÇŒ≥trr.*‚àÇœá./Œ≥trr
     - (1/6)*Œ±.*‚àÇŒ≥tŒ∏Œ∏.*‚àÇœá./Œ≥tŒ∏Œ∏ - (2/3)*‚àÇŒ±.*‚àÇœá - (1/3)*Œ±.*œá.*‚àÇ2Œ≥trr./Œ≥trr
     + (1/3)*Œ±.*œá.*‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏ - (2/3)*œá.*‚àÇ2Œ± + (1/3)*Œ±.*‚àÇ2œá)

    ‚àÇtK = ((3/2)*Œ±.*(Arr./Œ≥trr).^2 + (1/3)*Œ±.*K.^2 + Œ≤r.*‚àÇK
     + (1/2)*œá.*‚àÇŒ≥trr.*‚àÇŒ±./(Œ≥trr.^2) - œá.*‚àÇŒ±.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + (1/2)*‚àÇŒ±.*‚àÇœá./Œ≥trr - œá.*‚àÇ2Œ±./Œ≥trr)

    ‚àÇtŒìr = (-v*Œ≤r.*((‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2)./Œ≥trr + Œ±.*Arr.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./(Œ≥trr.^2)
     - (1/3)*v*‚àÇŒ≤r.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr + ‚àÇŒ≤r.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + Œ≤r.*‚àÇŒìr + Œ±.*Arr.*‚àÇŒ≥trr./(Œ≥trr.^3)
     - (4/3)*Œ±.*‚àÇK./Œ≥trr - 2*Arr.*‚àÇŒ±./(Œ≥trr.^2) + (1/2)*v*‚àÇŒ≤r.*‚àÇŒ≥trr./(Œ≥trr.^2)
     - (1/2)*‚àÇŒ≤r.*‚àÇŒ≥trr./(Œ≥trr.^2) - 3*Œ±.*Arr.*(‚àÇœá./œá)./(Œ≥trr.^2)
     + (1/6)*v*Œ≤r.*‚àÇ2Œ≥trr./(Œ≥trr.^2) + (1/3)*v*Œ≤r.*(‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + (1/3)*v*‚àÇ2Œ≤r./Œ≥trr + ‚àÇ2Œ≤r./Œ≥trr)

    ‚àÇtA = ‚àÇtK

    ‚àÇtBr = c*(‚àÇtŒìr + b*Œ≤r.*‚àÇBr - b*Œ≤r.*‚àÇŒìr - Œ∑*Br)

    #########################################################
    # Source Terms and Source Evolution
    #
    # This currently includes the addition of source terms
    # to GR that come from a Klein-Gordon scalar field
    #
    #########################################################

    # Klein-Gordon System

    ‚àÇtùúô = Œ≤r.*‚àÇùúô - 2*Œ±.*Kùúô
    ‚àÇtKùúô = (Œ≤r.*‚àÇKùúô + Œ±.*K.*Kùúô - (1/2)*Œ±.*œá.*‚àÇ2ùúô./Œ≥trr
        + (1/4)*Œ±.*œá.*‚àÇŒ≥trr.*‚àÇùúô./Œ≥trr.^2 - (1/4)*Œ±.*‚àÇœá.*‚àÇùúô./Œ≥trr
        - (1/2)*œá.*‚àÇŒ±.*‚àÇùúô./Œ≥trr - (1/2)*œá.*‚àÇŒ≥tŒ∏Œ∏.*‚àÇùúô./(Œ≥trr.*Œ≥tŒ∏Œ∏)
        + (1/2)*‚àÇœá.*‚àÇùúô./(Œ≥trr) + (1/2)*m^2*ùúô)

    # Inverse metric (contravariant indices)

    # gtt = -(1 ./Œ±.^2)
    # gtr = Œ≤r./Œ±.^2
    # grr = œá./Œ≥trr - (Œ≤r./Œ±).^2
    # gŒ∏Œ∏ = œá./Œ≥tŒ∏Œ∏
    #
    # # Lagrangian Density for scalar field
    #
    # ùìõ = (1/2)*gtt.*‚àÇtùúô.^2 + (1/2)*grr.*‚àÇùúô.^2 + gtr.*‚àÇùúô.*‚àÇtùúô - (1/2)*(m^2)*ùúô.^2
    #
    # # Stresss Energy components (contravariant indices)
    #
    # Ttt = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).^2 - gtt.*ùìõ
    # Trr = (gtr.*‚àÇtùúô + grr.*‚àÇùúô).^2 - grr.*ùìõ
    # Ttr = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).*(gtr.*‚àÇtùúô + grr.*‚àÇùúô) - gtr.*ùìõ
    # TŒ∏Œ∏ = -gŒ∏Œ∏.*ùìõ

    # Source Terms to GR
    # Sr here is a contravariant vector component
    # Srr here is a covariant tensor component

    # œÅ = (Œ±.^2).*Ttt
    # Sr = Œ±.*Ttr
    # Srr = ((Œ≥trr.^2)./(œá.^2)).*Trr
    # S = (Œ≥trr.*Trr + 2*Œ≥tŒ∏Œ∏.*TŒ∏Œ∏)./œá


    œÅ = 2*Kùúô.^2 + (1/2)*(œá./Œ≥trr).*‚àÇùúô.^2 + (1/2)*m^2*ùúô.^2
    Sr = 2*Kùúô.*‚àÇùúô
    S = 6*Kùúô.^2 - (1/2)*(œá./Œ≥trr).*‚àÇùúô.^2 - (3/2)*m^2*ùúô.^2
    Srr = (Œ≥trr./œá).*(2*Kùúô.^2 + (1/2)*(œá./Œ≥trr).*‚àÇùúô.^2 - (1/2)*m^2*ùúô.^2)


    ‚àÇtArr .+= -8*pi*Œ±.*(œá.*Srr - (1/3)*S.*Œ≥trr)
    ‚àÇtK .+= 4*pi*Œ±.*(œÅ + S)
    ‚àÇtŒìr .+= -16*pi*Œ±.*Sr./œá

    # Convert back to regularized variables

    # ‚àÇtŒìreg = -(r/2).*‚àÇtŒìr
    # ‚àÇtŒ≥tŒ∏Œ∏reg = (1 ./r.^2).*‚àÇtŒ≥tŒ∏Œ∏

    ‚àÇtŒ≥tŒ∏Œ∏reg = (1 ./r.^2).*‚àÇtŒ≥tŒ∏Œ∏
    # ‚àÇtArrreg = real((r .+ 0im).^(5/2)).*‚àÇtArr
    # ‚àÇtKreg = real((r .+ 0im).^(3/2)).*‚àÇtK

    # Numerical Dissipation terms

    ‚àÇ4Œ± = dissipation(Œ±)
    ‚àÇ4A = dissipation(A)
    ‚àÇ4Œ≤r = dissipation(Œ≤r)
    ‚àÇ4Br = dissipation(Br)
    ‚àÇ4œá = dissipation(œá)
    ‚àÇ4Œ≥trr = dissipation(Œ≥trr)
    ‚àÇ4Œ≥tŒ∏Œ∏reg = dissipation(Œ≥tŒ∏Œ∏reg)
    ‚àÇ4Arr = dissipation(Arr)
    ‚àÇ4K = dissipation(K)
    ‚àÇ4Œìr = dissipation(Œìr)
    ‚àÇ4ùúô = dissipation(ùúô)
    ‚àÇ4Kùúô = dissipation(Kùúô)

    #sign = -1 seems the best
    sign = -1
    œÉ = 0.3

    # ‚àÇtŒ± .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ±
    # ‚àÇtŒ≤r .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≤r
    # ‚àÇtBr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Br
    # ‚àÇtœá .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6œá
    # ‚àÇtŒ≥trr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≥trr
    # ‚àÇtŒ≥tŒ∏Œ∏ .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œ≥tŒ∏Œ∏
    # ‚àÇtArr .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Arr
    # ‚àÇtK .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6K
    # ‚àÇtŒìreg .+= (1/(2^6))*sign*œÉ*(drt^5)*‚àÇ6Œìreg

    ‚àÇtŒ± .+= (1/(16))*sign*œÉ*(drt^3)*‚àÇ4Œ±
    ‚àÇtA .+= (1/(16))*sign*œÉ*(drt^3)*‚àÇ4A
    ‚àÇtŒ≤r .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≤r
    ‚àÇtBr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Br
    ‚àÇtœá .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4œá
    ‚àÇtŒ≥trr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≥trr
    ‚àÇtŒ≥tŒ∏Œ∏reg .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œ≥tŒ∏Œ∏reg
    ‚àÇtArr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Arr
    ‚àÇtK .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4K
    ‚àÇtŒìr .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Œìr
    ‚àÇtùúô .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4ùúô
    ‚àÇtKùúô .+= (1/16)*sign*œÉ*(drt^3)*‚àÇ4Kùúô

    # Inner temporal boundary Conditions

    ‚àÇtŒ±[1:2] .= ‚àÇŒ±[1:2]
    ‚àÇtA[1:2] .= ‚àÇA[1:2]
    ‚àÇtŒ≤r[1:2] .= ‚àÇŒ≤r[1:2]
    ‚àÇtBr[1:2] .= ‚àÇBr[1:2]
    ‚àÇtœá[1:2] .= ‚àÇœá[1:2]
    ‚àÇtŒ≥trr[1:2] .= ‚àÇŒ≥trr[1:2]
    ‚àÇtŒ≥tŒ∏Œ∏reg[1:2] .= ‚àÇŒ≥tŒ∏Œ∏reg[1:2]
    ‚àÇtArr[1:2] .= ‚àÇArr[1:2]
    ‚àÇtK[1:2] .= ‚àÇK[1:2]
    ‚àÇtŒìr[1:2] .= ‚àÇŒìr[1:2]
    ‚àÇtùúô[1:2] .= ‚àÇùúô[1:2]
    ‚àÇtKùúô[1:2] .= ‚àÇKùúô[1:2]


    # Outer temporal boundary conditions

    ‚àÇtŒ±[(n-1):n] .= 0.
    ‚àÇtA[(n-1):n] .= 0.
    ‚àÇtŒ≤r[(n-1):n] .= 0.
    ‚àÇtBr[(n-1):n] .= 0.
    ‚àÇtœá[(n-1):n] .= 0.
    ‚àÇtŒ≥trr[(n-1):n] .= 0.
    ‚àÇtŒ≥tŒ∏Œ∏reg[(n-1):n] .= 0.
    ‚àÇtArr[(n-1):n] .= 0.
    ‚àÇtK[(n-1):n] .= 0.
    ‚àÇtŒìr[(n-1):n] .= 0.
    ‚àÇtùúô[(n-1):n] .= 0.
    ‚àÇtKùúô[(n-1):n] .= 0.

    # In case you want to freeze all GR variables

    # ‚àÇtŒ±[2:(n-1)] .= 0.
    # ‚àÇtŒ≤r[2:(n-1)] .= 0.
    # ‚àÇtBr[2:(n-1)] .= 0.
    # ‚àÇtœá[2:(n-1)] .= 0.
    # ‚àÇtŒ≥trr[2:(n-1)] .= 0.
    # ‚àÇtŒ≥tŒ∏Œ∏reg[2:(n-1)] .= 0.
    # ‚àÇtArr[2:(n-1)] .= 0.
    # ‚àÇtK[2:(n-1)] .= 0.
    # ‚àÇtŒìreg[2:(n-1)] .= 0.

    #Values at infinity
    # Œ±0 = 1
    # Œ≤r0 = 0
    # Br0 = 0
    # œá0 = 1
    # grr0 = 1
    # gŒ∏Œ∏reg0 = 0
    # Arr0 = 0
    # K0 = 0
    # Œìreg0 = 1
    #
    # ‚àÇtŒ±[(n-1):n] .= (Œ±[(n-1):n] .- Œ±0)./r[(n-1):n] - ‚àÇŒ±[(n-1):n] + hŒ±./(r[(n-1):n].^w)
    # ‚àÇtŒ≤r[(n-1):n] .= (Œ≤r[(n-1):n] .- Œ≤r0)./r[(n-1):n] - ‚àÇŒ≤r[(n-1):n] + hŒ≤r./(r[(n-1):n].^w)
    # ‚àÇtBr[(n-1):n] .= (Br[(n-1):n] .- Br0)./r[(n-1):n] - ‚àÇBr[(n-1):n] + hBr./(r[(n-1):n].^w)
    # ‚àÇtœá[(n-1):n] .= (œá[(n-1):n] .- œá0)./r[(n-1):n] - ‚àÇœá[(n-1):n] + hœá./(r[(n-1):n].^w)
    # ‚àÇtgrr[(n-1):n] .= (grr[(n-1):n] .- grr0)./r[(n-1):n] - ‚àÇgrr[(n-1):n] + hgrr./(r[(n-1):n].^w)
    # ‚àÇtgŒ∏Œ∏reg[(n-1):n] .= (gŒ∏Œ∏reg[(n-1):n] .- gŒ∏Œ∏reg0)./r[(n-1):n] - ‚àÇgŒ∏Œ∏reg[(n-1):n] + hgŒ∏Œ∏reg./(r[(n-1):n].^w)
    # ‚àÇtArr[(n-1):n] .= (Arr[(n-1):n] .- Arr0)./r[(n-1):n] - ‚àÇArr[(n-1):n] + hArr./(r[(n-1):n].^w)
    # ‚àÇtK[(n-1):n] .= (K[(n-1):n] .- K0)./r[(n-1):n] - ‚àÇK[(n-1):n] + hK./(r[(n-1):n].^w)
    # ‚àÇtŒìreg[(n-1):n] .= (Œìreg[(n-1):n] .- Œìreg0)./r[(n-1):n] - ‚àÇŒìreg[(n-1):n] + hŒìreg./(r[(n-1):n].^w)

    return GBSSN_Variables(‚àÇtŒ±,‚àÇtA,‚àÇtŒ≤r,‚àÇtBr,‚àÇtœá,‚àÇtŒ≥trr,‚àÇtŒ≥tŒ∏Œ∏reg,‚àÇtArr,‚àÇtK,‚àÇtŒìr,‚àÇtùúô,‚àÇtKùúô)

end

function constraints(T,state::GBSSN_Variables,param)

    ############################################
    # Caculates the constraints of the system
    #
    # These are outputed at every saved time step.
    # They should limit to zero as the spatial
    # resolution is increased. They are important to
    # monitor to make sure the physics of the system
    # is being properly modeled.
    ############################################

    # Unpack Variables

    Œ± = state.Œ±
    Œ≤r = state.Œ≤r
    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arr = state.Arr
    K = state.K
    Œìr = state.Œìr
    ùúô = state.ùúô
    Kùúô = state.Kùúô

    m = param[7]

    # Gauge conditions

    v = param[3]

    # if v == 1 # Lagrangian Condition
    #     Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4] - 126*Œ≥tŒ∏Œ∏reg[5]
    #     + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    # end

    # Spatial Derivatives

    order = 4

    # First derivatives
    ‚àÇrtœá = deriv(œá,order,1)
    ‚àÇrtŒ≥trr = deriv(Œ≥trr,order,1)
    ‚àÇrtŒ≥tŒ∏Œ∏reg = deriv(Œ≥tŒ∏Œ∏reg,order,1)
    ‚àÇrtArr = deriv(Arr,order,1)
    ‚àÇrtK = deriv(K,order,1)
    ‚àÇrtùúô = deriv(ùúô,order,1)

    # Second derivatives
    ‚àÇ2rtœá = deriv2(œá,order,1)
    ‚àÇ2rtŒ≥tŒ∏Œ∏reg = deriv2(Œ≥tŒ∏Œ∏reg,order,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    r = sample(Float64, œá.grid, param[4])
    drdrt = sample(Float64, œá.grid, param[5])
    d2rdrt = sample(Float64, œá.grid, param[6])

    ‚àÇœá = ‚àÇrtœá./drdrt
    ‚àÇŒ≥trr = ‚àÇrtŒ≥trr./drdrt
    ‚àÇŒ≥tŒ∏Œ∏reg = ‚àÇrtŒ≥tŒ∏Œ∏reg./drdrt
    ‚àÇArr = ‚àÇrtArr./drdrt
    ‚àÇK = ‚àÇrtK./drdrt
    ‚àÇùúô = ‚àÇrtùúô./drdrt

    ‚àÇ2œá = (‚àÇ2rtœá - d2rdrt.*‚àÇœá)./(drdrt.^2)
    ‚àÇ2Œ≥tŒ∏Œ∏reg = (‚àÇ2rtŒ≥tŒ∏Œ∏reg - d2rdrt.*‚àÇŒ≥tŒ∏Œ∏reg)./(drdrt.^2)

    #‚àÇtùúô = Œ≤r.*‚àÇùúô - 2*Œ±.*Kùúô

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇŒ≥tŒ∏Œ∏ = (r.^2).*‚àÇŒ≥tŒ∏Œ∏reg + (2*r).*(Œ≥tŒ∏Œ∏reg .+ 1)
    ‚àÇ2Œ≥tŒ∏Œ∏ = (r.^2).*‚àÇ2Œ≥tŒ∏Œ∏reg + (4*r).*‚àÇŒ≥tŒ∏Œ∏reg + 2*(Œ≥tŒ∏Œ∏reg .+ 1)

    # K = real((r .+ 0im).^(-3/2)).*Kreg
    # ‚àÇK = real((r .+ 0im).^(-3/2)).*‚àÇKreg - (3/2)*real((r .+ 0im).^(-5/2)).*Kreg
    #
    # Arr = real((r .+ 0im).^(-5/2)).*Arrreg
    # ‚àÇArr = real((r .+ 0im).^(-5/2)).*‚àÇArrreg - (5/2)*real((r .+ 0im).^(-7/2)).*Arrreg

    # Œìr = -(2 ./r).*Œìreg

    # Inverse metric (contravariant indices)

    # gtt = -(1 ./Œ±.^2)
    # gtr = Œ≤r./Œ±.^2
    # grr = œá./Œ≥trr - (Œ≤r./Œ±).^2
    # gŒ∏Œ∏ = œá./Œ≥tŒ∏Œ∏
    #
    # # Lagrangian Density for scalar field
    #
    # ùìõ = (1/2)*gtt.*‚àÇtùúô.^2 + (1/2)*grr.*‚àÇùúô.^2 + gtr.*‚àÇùúô.*‚àÇtùúô - (1/2)*(m^2)*ùúô.^2
    #
    # # Stresss Energy components (contravariant indices)
    #
    # Ttt = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).^2 - gtt.*ùìõ
    # Ttr = (gtt.*‚àÇtùúô + gtr.*‚àÇùúô).*(gtr.*‚àÇtùúô + grr.*‚àÇùúô) - gtr.*ùìõ
    #
    # # Source Terms to the constraints
    #
    # œÅ = (Œ±.^2).*Ttt
    # Sr = Œ±.*Ttr

    œÅ = 2*Kùúô.^2 + (1/2)*(œá./Œ≥trr).*‚àÇùúô.^2 + (1/2)*m^2*ùúô.^2

    Sr = 2*Kùúô.*‚àÇùúô

    # Constraint Equations

    ùìó = (-(3/2)*(Arr./Œ≥trr).^2 + (2/3)*K.^2 - (5/2)*((‚àÇœá.^2)./œá)./Œ≥trr
     + 2*‚àÇ2œá./Œ≥trr + 2*œá./Œ≥tŒ∏Œ∏ - 2*œá.*(‚àÇ2Œ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr + 2*‚àÇœá.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr
     + œá.*(‚àÇŒ≥trr./(Œ≥trr.^2)).*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏) - ‚àÇœá.*‚àÇŒ≥trr./(Œ≥trr.^2)
     + (1/2)*œá.*((‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏).^2)./Œ≥trr - 16*pi*œÅ)

    ùìúr = (‚àÇArr./Œ≥trr - (2/3)*‚àÇK - (3/2)*Arr.*(‚àÇœá./œá)./Œ≥trr
     + (3/2)*Arr.*(‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr - Arr.*‚àÇŒ≥trr./(Œ≥trr.^2)
     - 8*pi*Sr)

    ùìñr = -(1/2)*‚àÇŒ≥trr./(Œ≥trr.^2) + Œìr + (‚àÇŒ≥tŒ∏Œ∏./Œ≥tŒ∏Œ∏)./Œ≥trr

    ùìó[1:2] .= 0.
    ùìúr[1:2] .= 0.
    ùìñr[1:2] .= 0.

    return (ùìó, ùìúr, ùìñr, œÅ)

end

function horizon(T,state::GBSSN_Variables,param)

    ############################################
    # Caculates the apparent horizon
    #
    # Where the function crosses zero is the
    # apparent horizon of the black hole.
    ############################################

    v = param[3]

    # Unpack Variables

    œá = state.œá
    Œ≥trr = state.Œ≥trr
    Œ≥tŒ∏Œ∏reg = state.Œ≥tŒ∏Œ∏
    Arr = state.Arr
    K = state.K

    # Gauge condition

    # if v == 1 # Lagrangian Condition
    #     Œ≥tŒ∏Œ∏reg[2] = ((-315*Œ≥tŒ∏Œ∏reg[3] + 210*Œ≥tŒ∏Œ∏reg[4] - 126*Œ≥tŒ∏Œ∏reg[5]
    #     + 45*Œ≥tŒ∏Œ∏reg[6] - 7*Œ≥tŒ∏Œ∏reg[7])/63)
    # end

    r = sample(T, œá.grid, param[4])
    drdrt = sample(T, œá.grid, param[5])

    # Conversions from regularized variables to canonical variables

    Œ≥tŒ∏Œ∏ = (r.^2).*(Œ≥tŒ∏Œ∏reg .+ 1)

    # K = real((r .+ 0im).^(-3/2)).*Kreg
    #
    # Arr = real((r .+ 0im).^(-5/2)).*Arrreg

    # Intermediate calculations

    KŒ∏Œ∏ = ((1/3)*Œ≥tŒ∏Œ∏.*K - (1/2)*Arr.*Œ≥tŒ∏Œ∏./Œ≥trr)./œá

    grr =  Œ≥trr./œá

    gŒ∏Œ∏ =  Œ≥tŒ∏Œ∏./œá

    # Spatial Derivatives

    ‚àÇrtgŒ∏Œ∏ = deriv(gŒ∏Œ∏,4,1)

    # Coordinate transformations from computational rt coordinate
    # to physical r coordinate

    ‚àÇgŒ∏Œ∏ = ‚àÇrtgŒ∏Œ∏./drdrt

    # Apparent horizon function

    Œò = (‚àÇgŒ∏Œ∏./gŒ∏Œ∏)./real((grr .+ 0im).^(1/2)) - 2*KŒ∏Œ∏./gŒ∏Œ∏

    # cross = GridFun(œá.grid, sign.(Œò))

    return Œò

end

# function crossings(Œò::GridFun)
#
#     GridFun(œá.grid, sign.(Œò))
#
#     for
#
# end


function custom_progress_message(dt,state,param,t)

    ###############################################
    # Outputs status numbers while the program runs
    ###############################################

    if param[1]==param[2]
        println("")
        println("| # | Time Step | Time | max Œ±'(t) | max œá'(t) | max Œ≥trr'(t) | max Œ≥tŒ∏Œ∏'(t) | max Arr'(t) | max K'(t) | max Œìr'(t) |")
        println("|___|___________|______|___________|___________|______________|______________|_____________|___________|____________|")
        println("")
    end

    derivstate = rhs(state,param,t)

    println("  ",
    rpad(string(param[1]),6," "),
    rpad(string(round(dt,digits=3)),10," "),
    rpad(string(round(t,digits=3)),10," "),
    rpad(string(round(maximum(abs.(derivstate.Œ±)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.œá)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.Œ≥trr)),digits=3)),14," "),
    rpad(string(round(maximum(abs.(derivstate.Œ≥tŒ∏Œ∏)),digits=3)),14," "),
    rpad(string(round(maximum(abs.(derivstate.Arr)),digits=3)),12," "),
    # rpad(string(round(maximum(abs.(derivstate.ùúô)),digits=3)),12," "),
    # rpad(string(round(maximum(abs.(derivstate.Kùúô)),digits=3)),14," ")
    rpad(string(round(maximum(abs.(derivstate.K)),digits=3)),12," "),
    rpad(string(round(maximum(abs.(derivstate.Œìr)),digits=3)),14," ")
    )

    #PrettyTables.jl

    param[1] += param[2]

end


function solution_saver(T,grid,sol,param,folder)

    ###############################################
    # Saves all of the variables in nice CSV files
    # in the choosen data folder directory
    ###############################################

    vars = (["Œ±","A","Œ≤r","Br","œá","Œ≥trr","Œ≥tŒ∏Œ∏","Arr","K","Œìr","ùúô","Kùúô",
    "‚àÇtŒ±","‚àÇtA","‚àÇtŒ≤r","‚àÇtBr","‚àÇtœá","‚àÇtŒ≥trr","‚àÇtŒ≥tŒ∏Œ∏","‚àÇtArr","‚àÇtK","‚àÇtŒìr","‚àÇtùúô","‚àÇtKùúô",
    "H","Mr","Gr","œÅ","appHorizon"])
    varlen = length(vars)
    #mkdir(string("data\\",folder))
    tlen = size(sol)[3]
    rlen = grid.ncells + 4
    loc = sample(T, grid, param[4])
    #loc[1] =
    cons = Array{GridFun,2}(undef,tlen,4)
    derivs = Array{GBSSN_Variables,1}(undef,tlen)
    apphorizon = Array{GridFun,1}(undef,tlen)

    for i in 1:tlen
        derivs[i] = rhs(sol[i],param,0)
        cons[i,1:4] .= constraints(T,sol[i],param)
        apphorizon[i] = horizon(T,sol[i],param)
    end

    array = Array{T,2}(undef,tlen+1,rlen+1)

    array[1,1] = 0
    array[1,2:end] .= loc

    for j = 1:varlen
        if j < 13
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= sol[:,j,i-1]
            end
        elseif j < 25
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= derivs[i-1][:,j-12]
            end
        elseif j < 29
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= cons[i-1,j-24]
            end
        elseif j == varlen
            for i = 2:tlen+1
                array[i,1] = sol.t[i-1]
                array[i,2:end] .= apphorizon[i-1]
            end
        end

        CSV.write(
        string("data/",folder,"/",vars[j],".csv"),
        DataFrame(array, :auto),
        header=false
        )

    end

end

function main(points)

    ###############################################
    # Main Program
    #
    # Calls each of the above functions to run a
    # simulation. Sets up the numerical grid,
    # sets the gauge conditions, sets up a new
    # computational rt coordinate that makes the
    # physical r coordinate step larger near the
    # outer boundary, sets the initial conditions,
    # and finally runs the numerical DiffEq
    # package to run the time integration.
    #
    # All data is saved in the folder specified to
    # the solution_saver, each in their own CSV
    # file.
    ###############################################

    T = Float64
    rspan = T[1,210]
    rtspan = T[1,21]

    grid = setup(T, rtspan, points)
    drt = spacing(grid)
    dt = drt/4

    tspan = T[0,3]
    v = 1

    m = 0

    # f(b) = b*tan(rtspan[2]/b)-rspan[2]
    #
    # scale = find_zero(f, 0.64*rtspan[2])
    #
    # r(rt) = scale*tan(rt/scale)
    # drdrt(rt) = sec(rt/scale)^2
    # d2rdrt(rt) = (2/scale)*(sec(rt/scale)^2)*tan(rt/scale)

    r(rt) = rt
    drdrt(rt) = 1
    d2rdrt(rt) = 0

    atol = eps(T)^(T(3) / 4)

    #alg = KuttaPRK2p5()
    alg = RK4()

    #printlogo()

    printtimes = 1
    custom_progress_step = round(Int, printtimes/dt)
    step_iterator = custom_progress_step
    param = [step_iterator, custom_progress_step, v, r, drdrt, d2rdrt, m, rtspan]
    println("Defining Initial State...")
    state = init(T, grid, param)::GBSSN_Variables
    println("Defining Problem...")
    prob = ODEProblem(rhs, state, tspan, param)
    println("Starting Solution...")

    #init(T, grid, param)

    sol = solve(
        prob, alg,
        abstol = atol,
        dt = drt/4,
        adaptive = false,
        saveat = 1,
        progress = true,
        progress_steps=custom_progress_step,
        progress_message=custom_progress_message
    )

    solution_saver(T,grid,sol,param,"ScalarTests")

end


end
